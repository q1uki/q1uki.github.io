[{"title":"【学习记录】I2P概述","url":"/2026/01/08/i2p/","content":"简介I2P（Invisible Internet Project ）是去中心化的点到点（P2P）匿名网络，使用JAVA开发。与Tor类似，都是通过若干个网络节点来加密和传输数据，但匿名度比Tor更高。Tor主要致力于为用户提供匿名访问实施和操作外部的互联网服务，解决“匿名性”和“隐藏服务”，侧重应用层设计，构建了一个“覆盖网络”。I2P试图将现有互联网服务转移到I2P网络，并在框架内提供服务实现，提供匿名文件共享和匿名网络托管，解决“匿名性”、“隐藏服务”和“安全性”，侧重网络层设计，构建了一个“虚拟互联网”。（参考：https://www.hanspub.org/journal/paperinformation?paperID=31299&amp;btwaf=39457632）\n使用\n安装需要安装高于1.5的JAVA版本安装教程可以在官网找到，https://geti2p.net/en/download（官方注：在linux上不要用root启动i2p）\n\n连接I2P网络首次连接I2P网络需要补种，后面详细说。\n\n设置代理通过I2P访问网站需要设置本地代理，默认HTTP代理端口为4444，HTTPS为4445。\n\n\n启动成功后，访问127.0.0.1:7657就能看到I2P的控制台，包括设置和各项网络指标。网络指标：\n\n机制\nKad算法 用途：通过种子节点扩散获取网络节点信息、将传输的原始数据拆散为加密数据包通过多条隧道交叉疏散传递。\n\n  特点：  ① 拿到的只是整个I2P网络的一小部分节点  ② 不需要目录服务器  ③ 每一台运行I2P的主机都是网络中继，共享带宽帮别人转发数据  ④ 只要连上一次I2P，就能不断获取网络中部分其他节点的信息，保证与I2P网络维持连接\n\n网络数据库netdb\n\n大蒜路由要传输信息时，首先将要传输的信息分成多个子信息，然后从网络数据库（netdb）中随机选取可用的中间节点，构建多个加密隧道。\n① 隧道建立隧道时，隧道的发起者必须向发起者选出来的隧道的每一跳发送请求和必要的配置数据，并且等到每一跳的确认信息后才能开始建立隧道。隧道的发起者发送的建立隧道请求是加密的，并且只有隧道的创建者才能够访问每一跳的确认信息。隧道最大生命周期为10分钟。通常情况下，一条隧道有3跳，即网关节点、中间节点（可调整数量）、终点。一个完整的单向传输包括输出隧道和输入隧道，至少有6个节点参与其中。\n② 对等实体（peer）选择在选取可用中间节点中， I2P客户端依赖于先前监控的性能值和网络的当前状态，不使用有效带宽探测。I2P节点选择算法，能够非常快速地对失败的对等体和网络拓扑中的其他变化做出反应，通过不断分析和排名性能来选择对等体，而不是信任所声称的容量。（参考：http://www.3n1ac.com/index.php/archives/3/）\n③ 隧道创建当一个路由节点想要创建一条输出隧道的时候，它会首先查看自己的netDb文件夹，获取一系列的RouterInfor信息（这个信息是之前路由实时监测得到的），根据他们的性能和其他指标从其中挑选几个节点，并且将节点根据一定的算法进行严格的排序，之后为挑选出来的每一个节点配置好相应的信息，然后转发出去。\n 对于输出隧道来讲，隧道创建者就是隧道网关，将创建隧道的指令等之前配置好的信息按照之前挑选出来的、排好的顺序转发下一跳路由——隧道的中间节点，中间节点接收到指令之后，会了解到现在要创建一条隧道，它将指令会继续转发下去，然后会将请求记录替换成回复记录（说明是否同意参与隧道），继续转发到下一跳当中去。当消息一直转发到隧道的最后一个节点，即终点的时候，会按照之前的指令将消息转发到相应的输入隧道中去，最终返回到对应隧道创建者那里。\n 由于隧道的构建会有较大的时间成本和带宽负载，并且每条隧道有最高10分钟的生命周期，超过这个时间之后隧道就会被销毁，所以为了实现服务的高效运行，为应用提供冗余的带宽，每个I2P路由器都会维护一系列的隧道池，每个隧道池中的隧道用于同一种通信目的。\n④ 终点处理 在隧道的最后一跳接收并验证了隧道消息之后，终点如何恢复网关的数据同样取决于隧道是输入隧道还是输出隧道。 对于输出隧道，终点像其他参与者一样，使用其层密钥对消息进行加密、转发即可。 对于输入隧道，终点也是隧道创建者，因此它们可以使用与隧道节点路由的顺序相反的顺序，使用每层加密密钥和IV（隧道初始化向量）密钥迭代地解密IV密钥和消息。\n\n\n\nI2P与TOR对比\nI2P 大蒜路由 ① 完全去中心化，节点信息被保存在每一个I2P节点中，不需要目录服务器 ② 多条隧道传输接收和发送的信息，且每10分钟更换一次 ③ 传输的信息会被切分为多个子信息，通过不同加密隧道传输到目的地 ④ 速度慢\nTOR 洋葱路由 ① 依赖目录服务器获取中继节点，容易被封禁 ② 单条隧道传输接收和发送的信息 ③ 比I2P快\n\n补种由于Kad算法需要初始的种子来扩散获取更多节点信息，在初次连接I2P网络时需要补种，即利用一定数量的已知活跃节点来寻找其他节点。一旦连上了I2P，就能一直联网，若一段时间不使用（超过三个月），由于没有了最新的活跃I2P节点信息，才需要重新补种。I2P初始内置了种子节点信息，但有可能无效，需要其他方法补种。\n\n补种网站、文件I2P内置了几个补种网站，是默认补种方法。也可以自行在补种网站上下载补种文件，要求时效性高。自己可以创建补种文件分享给他人（节点信息来源于自身网络数据库）\n  附部分补种网站：\n  https://banana.incognet.io/https://i2p.novg.net/https://i2pseed.creativecowpat.net:8443/https://reseed-fr.i2pd.xyz/https://reseed-pl.i2pd.xyz/https://reseed.diva.exchange/https://reseed.i2pgit.org/https://reseed.memcpy.io/ https://reseed.onion.im/https://reseed2.i2p.net/https://app.box.com/s/aednqugd5zf07mlg65wjeafay3b1qqbg/folder/88436877456https://www2.mk16.de/https://i2phides.me/i2pseeds.su3\n\n补种文件从文件导入有zip和su3格式，su3是带有签名功能的压缩文件。解压后记事本打开可以看到一个I2P路由信息，包括NTCP和SSU两个协议的host、端口、密钥等信息，即控制台中netdb所显示的内容。乱码部分是su3的文件头信息，详细表格见官方文档。（官方文档：https://geti2p.net/spec/updates#su3）（根据不完全观察，每小时新增70个左右）\n\n\n网站I2P匿名站点（eepsite）是I2P网络内的网站。I2P站点的名称以.i2p结尾，通过识别密钥（即加密后的base64密钥，不同于常见base64，用~代替&#x2F;，用-代替+）寻找这些站点，已知站点密钥保存在本地host.txt文件中。\n\n地址簿I2P的网站密钥可以通过订阅地址簿、导航网站、自行导入地址访问。如：http://tino.i2p/hosts.txthttp://stats.i2p/cgi-bin/newhosts.txthttp://i2host.i2p/cgi-bin/i2hostetaghttp://no.i2p/export/alive-hosts.txthttp://notbob.i2p/hosts.txt以notbob为例，网站分类有搜索引擎、加密货币与交易、git、视频、sqbl等。\n网站首次访问未在地址簿中的网站时，可以通过跳转服务来找到该网站的密钥。\n\nI2P与TOR术语对比\n"},{"title":"【学习记录】六个RAT（远控木马）协议的通信特征（Gh0st, darkcomet, XtremeRAT, QuasarRAT, GreameRAT, njrat）","url":"/2026/01/08/rat/","content":"1 Gh0st1.1 基本情况Gh0stRAT最初由C.Rufus团队开发，客户端以服务的形式运行，可以随系统自启动，并通过隐藏文件和进程的方法躲避杀毒软件的检测。主要包括文件管理、系统信息收集、进程管理、屏幕截图、远程控制等模块，另外具有窃取密码、捕获网络流量和执行远程CMD命令的能力。通常通过电子邮件附件、恶意网站或软件漏洞传播。\n该木马于2009年被初次发现。其3.6版本的源代码在互联网上免费开源，因此备受欢迎，很多被修改的变种都由此而来，如大灰狼。2018年监测到Iron Tiger组织在攻击活动中使用Gh0stRAT变种，2021年监测到Gh0stRAT变种通过虚假Telegram安装程序在用户计算机上植入后门。\n1.2 基本特征\nTCP传输，默认监听端口为80，常见于8000、443 端口，默认伪装为 Microsoft Device Manager 服务\n数据(payload)头用明文显示magic number。如：Gh0st、GOLDt、HEART、Level、BeiJi\n固定的magic number会暴露自身版本信息\n对一些协议规范外的非法请求也会发出响应，如GET / HTTP/1.0\\r\\n\\r\\n\n缺少有效的包校验手段\n没有合理的会话管理机制\n源代码中，负责通信的发包方法是m_iocpServer()，Gh0stRAT虽然有多个变种，但此方法为各内核中核心的部分，通常不被修改，各变种有一个统一的通信特征。\n\n1.3 通信特征环境搭建参考：gh0st3.6 + vc6.0 + windows xp编译过程\n\n被控端发起请求信息\n\n整个通信过程中，用于传输数据的流量包的TCP标志位均包括PSH。在Gh0stRAT的握手中，被控端首先发起TCP连接请求。经过三次握手建立TCP连接后，被控端发送以”Gh0st\\xae\\x00\\x00\\x00\\xe0\\x00\\x00\\x00\\x78\\x9c“为前缀，包含经编码混淆后的自身系统信息的payload供上线。\n\n主控端响应\n\n主控端收到上线信息后，响应表示确认的流量包，Payload中同样以“Gh0st \\xae\\x00\\x00\\x00\\xe0\\x00\\x00\\x00\\x78\\x9c”为前缀。第14-15字节“\\x78\\x9c”为zlib的压缩头部，在Gh0st通信包中位置固定，见Gh0st大灰狼RAT家族通讯协议分析。\n2 DarkcometRAT2.1 基本情况DarkcometRAT在2008年由Jean-Pierre Lesueur开发，又称“暗黑彗星”，除了远控木马常见的加密和混淆技术外，还带有rootkit功能，允许在系统中隐藏自身存在。2012年，木马作者停止了对于这款木马的更新，最新版本停留在5.4.1。\n现在活跃的木马基本使用动态域名作为服务器域名，以“ddns.net”和“duckdns.org”为主，占比超过了50%。在腾讯反病毒实验室近年某月的威胁情报态势报告中发现，Darkcomet是该月使用最多的恶意网络协议，单日峰值达3000个。\n2.2 基本特征\nTCP传输，默认监听端口为1604\nRC4算法对通信流量进行加密和解密，主控端和被控端需要使用相同的密钥接受、发送信息\n使用预定义的命令字进行通信，参数之间用“|”隔开\n\n\n主控端发送“IDTYPE”命令字\n\n\n涉及传输数据的流量包的TCP标志位均包括PSH\n\n2.3 通信特征完成TCP三次握手后，主控端会用预先设定的密钥，发送经RC4算法加密后的命令字“IDTYPE”。\n默认密钥与版本有关，均形如“#KCMDDC𝑥#-8900123456789”， 𝑥为版本号，其中“0123456789”为用户可更改字段。\n具体对应如下表所示： \n\n随后被控端响应命令字“SERVER”密文，主控端接收后响应命令字“GetSIN”请求被控端主机信息并附带接收信息的数据库的IP地址，被控端接收后响应自身信息，完成Darkcomet握手。 \n2.4 平台对比shodan：搜索darkcomet，结果多在1604默认端口，且匹配响应均为V5的#KCMDDC5#-890密钥对应密文。360：多在3333端口，都是12位数时间戳，次多的6666端口，响应多为”000000009002”，应是误报，也包含shodan上的结果（都归在了“应用：darkcomet远控软件”里，此分类没有误报），同时还有“应用：darkcomet rat”分类，包含匹配时间戳的误报，猜测匹配规则是^[0-9A-F]{12}$。fofa：跟360类似。nmap：匹配规则也是^[0-9A-F]{12}$。(来源：darkcomet客户端与主控端进行tcp握手后，主控端会用预先设定的密钥，发送rc4算法加密后的命令字’IDTYPE’，默认密钥与版本有关。rc4加密后的密文长度为12位，由0-9和A-F构成。)\n3 njRAT3.1 基本情况njRAT，别名Bladabindi，于2013年首次被发现，使用.NET框架开发。2016年10月，Softpedia 报告称某破解版VMware下载会通过pastebin下载安装njRAT，若终止进程将会使计算机崩溃。2023年1月，木马病毒在中东地区扩散，攻击者使用.cab文件进行“政治对话”，实际在打开运行后会启动一个.vbs脚本，从云上下载njRAT安装到本地。\n3.2 基本特征\nTCP传输， 0.6.4版本的默认监听端口为1177，不同版本的默认端口不同\n涉及传输数据的流量包的TCP标志位均包括PSH\n参数之间用|’|’|隔开\n\n3.3 通信特征①client-&gt;server：上线被控端主动向主控端发起TCP连接，TCP三次握手完成后，发送自身信息以完成上线。参数之间用“|’|’|”隔开，后缀的关键字为“[endof]”。\n“lv”：命令字；“SGFjS2VkXzVDNjBFQUYz”：经base64编码后的被控端名称，即图中的“Name”；“WIN-GH46O995DIB”、“ win7”：被控端系统信息，对应图中 PC、user；“ 2023-02-21”：客户端安装时间，对应图中 Install Date；“\\x57\\x69\\x6e\\x20\\x37\\x20\\xbc\\xd2\\xcd\\xa5\\xc6\\xd5\\xcd\\xa8\\xb0\\xe6\\x20\\x53\\x50\\x31\\x20\\x78\\x36\\x34”：被控端操作系统名，对应图中“Operating system”；“No”：表示摄像头状况，这里没有，对应图中“Cam”；“0.6.4”：njRAT版本，对应图中“Ver.”；“5q2j5Zyo5o2V6I63IEFkYXB0ZXIgZm9yIGxvb3BiYWNrIHRyYWZmaWMgY2FwdHVyZQ&#x3D;&#x3D;”： base64 编码后的被控端活动窗口名，这里是“正在捕获 Adapter for loopback traffic capture”，为 Wireshark的窗口，对应图中“Active Window”。 \n通信流量捕获：\nserver端控制台：\n②server-&gt;client：主控端响应“CAP|’|’|”， 表示捕获受害主机画面。\n ③client-&gt;server： 被控端发送经编码的屏幕截图信息。\n ④server-&gt;client：主控端发送关键字“P”保持连接，接下来重复此行为。\n⑤client-&gt;server：被控端响应经base64 编码后的活跃窗口名，这里为 njRAT的窗口，同时响应关键字“P”保持连接，接下来重复此行为。\n\n4 GreameRAT4.1 基本情况GreameRAT公布于2012年，来源于摩洛哥，使用Pascal语言开发， Delphi的unicode版本编译，同样具有模块化体系结构，允许攻击者根据自身需要添加或删除功能。\n4.2 基本特征GreameRAT 使用 TCP传输，除 1.9版本外，其余默认监听端口均为777、888、999，1.9版本的默认端口仅有999。被控端和主控端握手通信中包含数据交换的流量包，其 TCP 标志位均包括PSH，其中密钥为默认的“123456”。\n4.3 通信特征在 GreameRAT 握手中，被控端首先发送包含密钥长度n的数字，在测试环境中，发现25为固定常数，25+n即为发送的数字，在本次握手中为31，以“\\x7c\\0a”为后缀。\n被控端紧接着发送与密钥有关的校验数据。 \n只有当两个数据都正确，主控端才会依次响应“\\x20\\x0d\\x0a”表示接收，以及后缀为“###@@@”的数据，完成握手。\n另外发现，若被控端除发送正确校验数据外，还发送了其他数据，主控端则会响应“tentarnovamente|”，是葡萄牙语的“tentar novamente”，意为重试。 \n5 QuasarRAT5.1 基本情况QuasarRAT 由 github 用户 MaxXor 采用 C#开发，首次公开于 2014年 7月，曾名“xRAT”，主要针对 Windows 操作系统，采用计划任务和注册表项维持自身持久存在。2018年2月，研究人员观察到一起通过恶意RTF文件分发QuasarRAT 作为最终有效载荷的攻击活动；2019年5月，enSilo观察到APT10使用PlugX 和 QuasarRAT 对东南亚政府和私人组织发起攻击。除此之外，著名的 APT攻击组织 “摩诃草”也曾长期使用此工具。\n5.2 基本特征QuasarRAT 使用 TCP 传输，常见监听端口为 5678，与数据传输相关的流量包中，TCP标志位均包括PSH。\n5.3 通信特征被控端主动向主控端发起 TCP连接，成功完成TCP连接后，主控端依次发送两个响应：“RPCMethod: preinstall”是 QuasarRAT 的命令，用于在目标主机上预安装Quasar客户端，是QuasarRAT主控端区别于其他端口服务的通信特征。\n6 XtemeRAT6.1 基本情况XtemeRAT发布于2010年，使用Delphi的Unicode版本开发，在GitHub 平台上开源，主要支持功能有文件与进程管理、键盘记录、服务管理和注册表管理。曾被北非狐（APT-C-44）组织用于针对阿拉伯语地区的攻击中。\n6.2 基本特征XtremeRAT使用 TCP传输，默认监听端口为80、81、82，默认密码为1234567890。\n6.3 通信特征被控端主动发起 TCP握手，完成 TCP三次握手建立连接后，被控端首先发送版本信息“myversion|3.2”。主控端回复第一个响应“X\\n\\r”，作为响应前缀，是XtremeRAT的通信特征。着主控端回复第二个响应，payload 中第 1-8 字节为密钥，在此例中密码为1234，第9-16字节为zlib压缩文件大小，此例中消息长度为152字节，均为小端序表示，第17-18字节为zlib指示符“\\x78\\x01”，在XtremeRAT通信中固定。\n6.4 尝试编译源代码（没完成，后来找到了exe）\n在delphi2010安装virtual tree view，将文件夹复制到$(BDS)\\Components\\VST\ndelphi7上安装KOL unicode组件，或在delphi2010上安装“MirrorKOLPackageD12.dpk”。执行正常KOL安装，然后获取Unicode版本文件并替换。感天动地，把那串乱码删掉就能装了\n创建项目：\n\n\n打开delphi7并转到：文件|新建|其他\n选择“向导”选项。将有一个KOL调色板。\n我做了一些修改，只能用作UNICODE，也就是说，不要在项目中使用“ansi”。\n打开文件“XtremeRAT.rar Components”并将数据复制到文件夹“$（BDS）\\Components\\”\n\n\n在delphi 2010中安装TMS组件\ndelphi2010|| Options | Environment Options | Delphi Options | Library - Win32 |\n\n$(BDS)\\Source\\Indy\\indy10\\System$(BDS)\\Source\\Indy\\indy10\\Core$(BDS)\\Source\\Indy\\indy10\\协议$(BDS)\\Components\\TMS\n\n安装AlphaControls.7.26组件，安装后将文件复制到$(BDS)\\Components\\AlphaControls\\D2010文件夹，然后转到delphi 2010中的工具选项|选项|环境选项| delphi选项|库-Win32|$（BDS）\\Components\\AlphaControls\\D2010\n\n"},{"title":"【论文阅读】《Detecting probe resistant proxy》实验验证与分析","url":"/2026/01/10/obfs4_bridge_scan/","content":"《detecting probe resistant proxy》论文阅读，对其中obfs4部分进行验证实验，并分析了obfs4proxy的部分源代码结构和函数、obfs4协议及其使用的加密方法和身份验证方式。\n引言当时看到这篇对代理检测的论文，对它的中文讨论较少，整理了自己阅读和实验后的笔记（关注于tor的obfs4），方便有需要的同学一起学习讨论。（现在obfs4将要过时，推出了新的WebTunnels，但升级迭代仍需时间）\n论文阅读探针选择我们的攻击集中在这样一个观察上，即从不使用数据进行响应是互联网上的异常行为。通过发送由流行协议和随机数据组成的探针，我们可以从超过400k IP&#x2F;端口对的Tap数据集中的几乎所有端点（94%）获得响应。对于不响应的端点，代理特有的TCP行为（如超时和数据阈值）与其他服务器相比存在不同。  \n从6个基本探测开始：HTTP、TLS、MODBUS、S7、随机字节，以及连接后不发送数据的空探测。对于每个探测，我们都会记录服务器如何响应其响应的数据（如果有）、关闭连接的时间（如果有）以及如何关闭连接（TCP FIN或RST）。\n\nHTTP：对于HTTP，我们发送一个简单的HTTP&#x2F;1.1 GET请求，主机头为example.com。大部分服务器将响应重定向或错误页面进行响应。即使不是HTTP的服务器也可能使用其协议固有的错误消息对此探测作出响应。\n\nTLS：我们发送一条TLS客户端Hello消息，该消息通常由Chromium版本71浏览器生成。这包括流行的密码套件和扩展，即使服务器不支持TLS，也应该响应TLS警报消息。\n\nModbus：Modbus通常用于监控和数据采集（SCADA）环境中的可编程逻辑控制器（PLC）和其他嵌入式设备。使用了ZGrab中定义的探针，它发送一个3字节的命令，从远程主机请求设备信息描述符。\n\nS7:S7是西门子PLC设备使用的专有协议。再次使用ZGrab中定义的探针，该探针通过COTP&#x2F;S7协议发送设备标识符请求。\n\n随机字节：不同数量随机字节的探测，服务器将解析失败，并以错误消息响应，或者以区别于代理服务器的方式关闭连接。\n\n空探针：在连接后不发送数据。一些协议（如SSH）让服务器首先（或同时）与客户端通信。对于其他协议，当客户端发送了一些初始数据时，与不发送数据时相比，实现可能具有不同的超时。  \n\nDNS AXFR：根据DNS规范构建了一个DNS AXFR（区域传输）查询探测。\n\nSTUN: 实现了一个基于ZGrab-Golang库的STUN探测，用于探测Cisco WebEx设备\n\n\n实验数据\n代理端点从Tor的BridgeDB收集了20多个obfs4代理端点\n\n非代理端点使用ZMap的主动网络扫描和网络流数据的被动收集。我们使用ZMap向每个TCP端口（0-65535）上的20000个主机发送一个SYN数据包，总共有13亿次探测。发现了150万个响应SYN ACK的端点，我们将其标记为ZMap数据集。科罗拉多大学的10 Gbps网关中采样netflow数据来收集端点。在无网络审查国家中，绝大多数流量不包含代理，所以收集到的端点主要是其他服务。在3天的时间跨度内，从ISP收集了超过550000个服务器IP&#x2F;端口 的节点。其中，433286（79%）个主机接受了连接（使用一个TCP SYN-ACK响应），其余的大多数在尝试连接时只是超时。后续扫描是在观察到连接后的几天内进行的，一些服务器可能在这段时间内移动了IP或离线。其次，服务器可能配置了防火墙，只允许从某些IP进行访问，可能会阻塞ZMap扫描主机。最终在这个数据集中捕获超过40万个发送数据的服务器。\n\n\n实验结果我们向190万个节点发送13个探测（第III-A节中的7个探测和6个随机数据范围为4KB-40KB的探测），并记录服务器是否和何时响应数据或关闭连接。如果服务器关闭，我们将记录它是否使用FIN或RST。如果服务器没有响应或关闭连接，我们将在300秒后超时，并将结果标记为超时。记录他们的关闭阈值。\n由于抗探测代理从不响应数据，因此可以将响应的端点丢弃。在被动Tap数据集中，这排除了94%的主机，只留下26021个潜在代理。在ZMap数据集中，绝大多数主机对任何探测都没有数据响应，仅丢弃1.16%的端点 。\n原因是ZMap识别的节点中，防火墙使用了chaff策略，仅在特定的子网上对SYN做出响应。42%的节点行为相同，不发送数据也不关闭与探测器的连接。将响应数据聚类（响应类型、响应字节数、连接关闭时间或超时时间） 在Tap数据集中，最流行的响应组包含3%的端点，似乎是Cloudflare网络中的TLS服务器（99.9％在具有端口443的端点上）。图2显示了ZMap和Tap数据集的不同响应集（按流行程度排序）的CDF，说明Tap数据集中有更大的多样性。前10个响应集占ZMap数据集中超过80%的端点，但只有13%的端点是在Tap中收集的。\n检测方法\n缓冲阈值 服务器将在接收到一定数量的字节后使用FIN关闭，并可能在接收到更高数量的字节之后使用RST关闭。代理服务的关闭阈值大多数是唯一的。 考虑一个从客户端读取N个字节并尝试将其解析为协议头的服务器。如果解析失败（例如无效字段、校验和或MAC），服务器可以简单地关闭连接。 如果客户端仅发送N−1字节，服务器可能会保持连接打开，并在尝试解析之前等待其他数据。  \n obfs4握手长度可达8192字节，因此服务器在确定客户端无效并进入closeAfterDelay函数之前读取了这么多字节。此函数在随机延迟（30-90秒）后关闭连接，或在服务器启动时读取额外的N个字节（在0和8192之间随机选择的N个）后关闭。然而，这些读取都是使用1448字节的缓冲区完成的。这意味着，如果发送了$8192+N$字节，obfs4服务器将发送FIN，如果发送$8192 + N − ((8192 + N)mod 1448) + 1448$字节，则返回rst。是obfs4独有行为。  \n 论文作者与torproject交流研究成果后，obfs4proxy已于0.0.11版本修复关闭阈值的行为。\n\n超时时间许多端点根据其接收的数据量具有不同的超时。不确认数据的主机不是标准的TCP行为，我们会重传，代理不会有这种行为，不影响结果。  \n 修复关闭阈值，但仍能观察到超时行为。\n\n不响应任何探测是罕见的。\n\n\nobfs4proxy分析obfs4协议验证逻辑握手过程sequenceDiagram\n    Client-&gt;&gt;Server: SYN+ECN+CWR\n    Server--&gt;&gt;Client: SYN+ACK \n    Client-&gt;&gt;Server: ACK\n    Client-&gt;&gt;Server: PSH+ACK+data\n\ndata内容涉及算法：curve25519\n客户端及服务端都必须有自己的Keypair实例。根据curve25519包中的定义，PrivateKey在一定范围内随机生成。根据ECC算法，PublicKey可以通过调用curve25519.ScalarBaseMult()从私钥生成。  \nRepresentative秘钥根据公钥生成，在需要的时候可以调用extra25519.RepresentativeToPublicKey()函数再次转换为公钥。Keypair的定义及初始化代码位于NewKeypair()函数中，该函数在ntor.go文件中定义。\n用extra25519.go里的ScalarBaseMult()，根据privatekey生成public和representative。representative通过Elligator 2映射完成混淆，避免收集到相当数量的公钥后推断出加密算法。算法详细说明\n客户端及服务端都应当保存好私钥，将公钥以Representative秘钥的形式发送给对方。Obfs4客户端的连接过程从握手报文开始，因此我们来看一下客户端的握手报文。该报文的整体结构如下所示：\n\n\nKeypair.representative，其长度为20h字节。在服务器端，它可以作为还原客户端的公钥。（obfs4 bridge配置行）\n使用随机字节的填充数据，其数据大小范围在4Dh至1FC0h之间，该填充数据会混淆握手数据包的大小，从而使其更难识别。\n第一部分Keypair.representative的HMAC值。Obfs4使用SHA-256生成HMAC，长度为20h字节。Obfs4仅将前10h字节保留为HMAC，其余10h字节将被丢弃。  \nObfs4使用当前系统时间来计算UNIX Epoch时间（从UTC时间1970年1月1日星期四00:00:00开始）的小时值。计算数据包中前三个部分的HMAC值，加上（指拼接起来）字符串中的小时值。同样，其结果长度为20h字节，前10h字节作为数据包的第四部分。（防重放）\n\nobfs4proxy源代码部分结构common&#x2F;  密码学、socks5等组件    \ninternal&#x2F;  更新的混淆算法  \nobfs4proxy&#x2F;obfs4proxy.go  主函数  \ntransports&#x2F;包含meeklite、obfs2、3、4、 scramblesuit传输协议的实现   \n\nobfs4&#x2F;  \nframing&#x2F; 数据帧的处理  \nhandshake_ntor.go 完成obfs4握手，包括验证  \nobfs4.go 握手相关函数\n\n\n\n\n\nobfs4proxy源代码部分函数obfs4.go\nWrapConn()调用了serverHandshake()，不管返回什么错，都closeAfterDelay()。  \n\nserverHandshake()新建服务端握手，设置基准超时时间。然后按能读取的最大长度（8192）设置缓冲区，读取收包，保存收包内容，接下来parseClientHandshake()解析内容。如果解析错误是ErrMarkNotFoundYet，继续读包，其他错误则函数返回错误。解析正常则清空缓冲区。\n\n\nhandshake_ntor.go\nparseClientHandshake()对于接收内容过少&#x2F;接收内容长度未达上限时，或找不到MarkMAC，准备了ErrMarkNotFoundYet的错误处理，可以返回继续读。其他错误都关闭连接。找不到markMAC&#x2F;HMAC&#x2F;包长度不合规（有握手中不需要的数据），返ErrInvalidHandshake。重放，返ErrReplayedHandshake。计算验证不通过，返ErrNtorFailed。  \n\ncloseAfterDelay()closeAfterDelay()被修改，修复了因阈值产生FIN和RST的漏洞。旧版本会在延迟30s&#x2F;接收一定长度数据后终止连接，新版本都是延迟30s终止连接。  \n\nSetReadDeadline()开始读数据30s后，再有数据进入也返回超时错误，并终止连接。（论文里说有随机延迟，我没找到）\n\n\nobfs4proxy.go\nparseClientHandshake()对于接收内容过少&#x2F;接收内容长度未达上限时，或找不到MarkMAC，准备了ErrMarkNotFoundYet的错误处理，可以返回继续读。其他错误都关闭连接。找不到markMAC&#x2F;HMAC&#x2F;包长度不合规（有握手中不需要的数据），返ErrInvalidHandshake。重放，返ErrReplayedHandshake。计算验证不通过，返ErrNtorFailed。  \n\ncloseAfterDelay()closeAfterDelay()被修改，修复了因阈值产生FIN和RST的漏洞。旧版本会在延迟30s&#x2F;接收一定长度数据后终止连接，新版本都是延迟30s终止连接。  \n\nSetReadDeadline()开始读数据30s后，再有数据进入也返回超时错误，并终止连接。（论文里说有随机延迟，我没找到）\n\n\n分析与实验论文简析论文人工构造的obfs4决策树中，首先随机发送17k的数据，2s内返回RST则进入下一步，发送其他探针，30s–90s之内返回FIN，则为obfs4。17k数据是为了引发阈值问题，已被修复，但延时FIN的情况仍然存在。\n论文中针对obfs4 bridge的实验数据过少，我决定自己实验验证。在测试了几个已知obfs4 bridge后，我发现巧合的，每一个bridge都有固定的超时时间。\n猜想：每一个bridge都有固定的超时时间。（有可能bridge在重启服务后会改变？随机延时时间只生成一次？）对6个已知obfs4 bridge进行测试，发送同样的data（重放tor浏览器发起的成功握手中的data），命中了验证不通过的错误，进入closeAfterDelay()。对每个bridge发起两次握手。对于同一bridge，在两个不同ip客户端上，发起的两次握手均经过相同时间后返回FIN，时间均落在[30,90]s。 \n实验验证\n测试集：对测试集进行验证过滤后，得到四百余存活服务。\n\n判断条件：TLS和HTTP探针无响应，17k字节返回RST或超时时间（返回FIN）为[30,90]s。\n\n实验结果：  \n① 80%服务判断为obfs4 bridge。其中，50%返回RST，50%超时时间在范围内。② 6%服务判断不为obfs4 bridge。③ 10%服务无法确定，发17k字节立刻收到FIN，TLS和HTTP均超时。\n\n\n实验分析\n80%bridge服务命中判断条件，验证了判断条件可行。\n6%服务中，发送TLS和HTTP均有回应，可探测出其他服务，应是提供的服务发生了变化，符合预期。\n剩下10%服务，未命中判断条件，但是挑了几个，在tor浏览器中设置配置行后，可以作为bridge使用。发送20k字节后，50%返回RST。重放obfs4握手data之后，全部在[30,90]s内FIN。猜测这些是已升级至新版本的bridge服务，重放握手数据后，则检验失败，进入延迟FIN函数。但是20k已经超过了论文所观察到的RST阈值，后来再发了30k，只有少数个响应RST。\n\n实验结论\n发送足够大的随机数据，马上返回RST（obfs4proxy 0.0.11版本已修复）  \n发送符合握手长度数据，[30,90]s内返回FIN\n\n后续结合其他特征后，已实现主动收集方案。\n相关资料torproject对于ORPort的讨论(move to here)论文精读论文讨论issuetorproject会议记录torproject聊天记录  \n"},{"title":"Hello World","url":"/2026/01/08/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]