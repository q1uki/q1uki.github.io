[{"url":"/2026/01/08/i2p/","content":"简介I2P（Invisible Internet Project ）是去中心化的点到点（P2P）匿名网络，使用JAVA开发。与Tor类似，都是通过若干个网络节点来加密和传输数据，但匿名度比Tor更高。Tor主要致力于为用户提供匿名访问实施和操作外部的互联网服务，解决“匿名性”和“隐藏服务”，侧重应用层设计，构建了一个“覆盖网络”。I2P试图将现有互联网服务转移到I2P网络，并在框架内提供服务实现，提供匿名文件共享和匿名网络托管，解决“匿名性”、“隐藏服务”和“安全性”，侧重网络层设计，构建了一个“虚拟互联网”。（参考：https://www.hanspub.org/journal/paperinformation?paperID=31299&amp;btwaf=39457632）\n使用\n安装需要安装高于1.5的JAVA版本安装教程可以在官网找到，https://geti2p.net/en/download（官方注：在linux上不要用root启动i2p）\n\n连接I2P网络首次连接I2P网络需要补种，后面详细说。\n\n设置代理通过I2P访问网站需要设置本地代理，默认HTTP代理端口为4444，HTTPS为4445。\n\n\n启动成功后，访问127.0.0.1:7657就能看到I2P的控制台，包括设置和各项网络指标。网络指标：\n机制\nKad算法 用途：通过种子节点扩散获取网络节点信息、将传输的原始数据拆散为加密数据包通过多条隧道交叉疏散传递。\n 特点： ① 拿到的只是整个I2P网络的一小部分节点 ② 不需要目录服务器 ③ 每一台运行I2P的主机都是网络中继，共享带宽帮别人转发数据 ④ 只要连上一次I2P，就能不断获取网络中部分其他节点的信息，保证与I2P网络维持连接\n\n网络数据库netdb\n\n大蒜路由要传输信息时，首先将要传输的信息分成多个子信息，然后从网络数据库（netdb）中随机选取可用的中间节点，构建多个加密隧道。\n ① 隧道 建立隧道时，隧道的发起者必须向发起者选出来的隧道的每一跳发送请求和必要的配置数据，并且等到每一跳的确认信息后才能开始建立隧道。隧道的发起者发送的建立隧道请求是加密的，并且只有隧道的创建者才能够访问每一跳的确认信息。隧道最大生命周期为10分钟。通常情况下，一条隧道有3跳，即网关节点、中间节点（可调整数量）、终点。一个完整的单向传输包括输出隧道和输入隧道，至少有6个节点参与其中。\n ② 对等实体（peer）选择 在选取可用中间节点中， I2P客户端依赖于先前监控的性能值和网络的当前状态，不使用有效带宽探测。I2P节点选择算法，能够非常快速地对失败的对等体和网络拓扑中的其他变化做出反应，通过不断分析和排名性能来选择对等体，而不是信任所声称的容量。 （参考：http://www.3n1ac.com/index.php/archives/3/）\n ③ 隧道创建 当一个路由节点想要创建一条输出隧道的时候，它会首先查看自己的netDb文件夹，获取一系列的RouterInfor信息（这个信息是之前路由实时监测得到的），根据他们的性能和其他指标从其中挑选几个节点，并且将节点根据一定的算法进行严格的排序，之后为挑选出来的每一个节点配置好相应的信息，然后转发出去。\n 对于输出隧道来讲，隧道创建者就是隧道网关，将创建隧道的指令等之前配置好的信息按照之前挑选出来的、排好的顺序转发下一跳路由——隧道的中间节点，中间节点接收到指令之后，会了解到现在要创建一条隧道，它将指令会继续转发下去，然后会将请求记录替换成回复记录（说明是否同意参与隧道），继续转发到下一跳当中去。当消息一直转发到隧道的最后一个节点，即终点的时候，会按照之前的指令将消息转发到相应的输入隧道中去，最终返回到对应隧道创建者那里。\n 由于隧道的构建会有较大的时间成本和带宽负载，并且每条隧道有最高10分钟的生命周期，超过这个时间之后隧道就会被销毁，所以为了实现服务的高效运行，为应用提供冗余的带宽，每个I2P路由器都会维护一系列的隧道池，每个隧道池中的隧道用于同一种通信目的。\n ④ 终点处理  在隧道的最后一跳接收并验证了隧道消息之后，终点如何恢复网关的数据同样取决于隧道是输入隧道还是输出隧道。 对于输出隧道，终点像其他参与者一样，使用其层密钥对消息进行加密、转发即可。 对于输入隧道，终点也是隧道创建者，因此它们可以使用与隧道节点路由的顺序相反的顺序，使用每层加密密钥和IV（隧道初始化向量）密钥迭代地解密IV密钥和消息。\n\n\n\nI2P与TOR对比\nI2P 大蒜路由 ① 完全去中心化，节点信息被保存在每一个I2P节点中，不需要目录服务器 ② 多条隧道传输接收和发送的信息，且每10分钟更换一次 ③ 传输的信息会被切分为多个子信息，通过不同加密隧道传输到目的地 ④ 速度慢\nTOR 洋葱路由 ① 依赖目录服务器获取中继节点，容易被封禁 ② 单条隧道传输接收和发送的信息 ③ 比I2P快\n\n补种由于Kad算法需要初始的种子来扩散获取更多节点信息，在初次连接I2P网络时需要补种，即利用一定数量的已知活跃节点来寻找其他节点。一旦连上了I2P，就能一直联网，若一段时间不使用（超过三个月），由于没有了最新的活跃I2P节点信息，才需要重新补种。I2P初始内置了种子节点信息，但有可能无效，需要其他方法补种。\n\n补种网站、文件I2P内置了几个补种网站，是默认补种方法。也可以自行在补种网站上下载补种文件，要求时效性高。自己可以创建补种文件分享给他人（节点信息来源于自身网络数据库）\n  附部分补种网站：\n  https://banana.incognet.io/https://i2p.novg.net/https://i2pseed.creativecowpat.net:8443/https://reseed-fr.i2pd.xyz/https://reseed-pl.i2pd.xyz/https://reseed.diva.exchange/https://reseed.i2pgit.org/https://reseed.memcpy.io/ https://reseed.onion.im/https://reseed2.i2p.net/https://app.box.com/s/aednqugd5zf07mlg65wjeafay3b1qqbg/folder/88436877456https://www2.mk16.de/https://i2phides.me/i2pseeds.su3\n\n补种文件从文件导入有zip和su3格式，su3是带有签名功能的压缩文件。解压后记事本打开可以看到一个I2P路由信息，包括NTCP和SSU两个协议的host、端口、密钥等信息，即控制台中netdb所显示的内容。乱码部分是su3的文件头信息，详细表格见官方文档。（官方文档：https://geti2p.net/spec/updates#su3）（根据不完全观察，每小时新增70个左右）\n\n\n网站I2P匿名站点（eepsite）是I2P网络内的网站。I2P站点的名称以.i2p结尾，通过识别密钥（即加密后的base64密钥，不同于常见base64，用~代替&#x2F;，用-代替+）寻找这些站点，已知站点密钥保存在本地host.txt文件中。\n\n地址簿I2P的网站密钥可以通过订阅地址簿、导航网站、自行导入地址访问。如：http://tino.i2p/hosts.txthttp://stats.i2p/cgi-bin/newhosts.txthttp://i2host.i2p/cgi-bin/i2hostetaghttp://no.i2p/export/alive-hosts.txthttp://notbob.i2p/hosts.txt以notbob为例，网站分类有搜索引擎、加密货币与交易、git、视频、sqbl等。\n网站首次访问未在地址簿中的网站时，可以通过跳转服务来找到该网站的密钥。\n\nI2P与TOR术语对比\n"},{"title":"【学习记录】obfs4proxy 协议验证方式和部分源代码结构、函数分析","url":"/2026/01/08/obfs4/","content":"obfs4协议验证逻辑握手过程sequenceDiagram\n    Client-&gt;&gt;Server: SYN+ECN+CWR\n    Server--&gt;&gt;Client: SYN+ACK \n    Client-&gt;&gt;Server: ACK\n    Client-&gt;&gt;Server: PSH+ACK+data\n\ndata内容涉及算法：curve25519\n客户端及服务端都必须有自己的Keypair实例。根据curve25519包中的定义，PrivateKey在一定范围内随机生成。根据ECC算法，PublicKey可以通过调用curve25519.ScalarBaseMult()从私钥生成。  \nRepresentative秘钥根据公钥生成，在需要的时候可以调用extra25519.RepresentativeToPublicKey()函数再次转换为公钥。Keypair的定义及初始化代码位于NewKeypair()函数中，该函数在ntor.go文件中定义。\n用extra25519.go里的ScalarBaseMult()，根据privatekey生成public和representative。representative通过Elligator 2映射完成混淆，避免收集到相当数量的公钥后推断出加密算法。  \n算法详细说明验证逻辑：\n客户端及服务端都应当保存好私钥，将公钥以Representative秘钥的形式发送给对方。Obfs4客户端的连接过程从握手报文开始，因此我们来看一下客户端的握手报文。该报文的整体结构如下所示：\n\n\nKeypair.representative，其长度为20h字节。在服务器端，它可以作为还原客户端的公钥。（obfs4 bridge配置行）\n使用随机字节的填充数据，其数据大小范围在4Dh至1FC0h之间，该填充数据会混淆握手数据包的大小，从而使其更难识别。\n第一部分Keypair.representative的HMAC值。Obfs4使用SHA-256生成HMAC，长度为20h字节。Obfs4仅将前10h字节保留为HMAC，其余10h字节将被丢弃。  \nObfs4使用当前系统时间来计算UNIX Epoch时间（从UTC时间1970年1月1日星期四00:00:00开始）的小时值。计算数据包中前三个部分的HMAC值，加上（指拼接起来）字符串中的小时值。同样，其结果长度为20h字节，前10h字节作为数据包的第四部分。（防重放）\n\nobfs4proxy源代码部分结构\ncommon&#x2F;  密码学、socks5等组件    \ninternal&#x2F; 更新的混淆算法  \nobfs4proxy&#x2F;obfs4proxy.go  主函数  \ntransports&#x2F;包含meeklite、obfs2、3、4、 scramblesuit传输协议的实现   \nobfs4&#x2F;  \nframing&#x2F; 数据帧的处理  \nhandshake_ntor.go 完成obfs4握手，包括验证  \nobfs4.go 握手相关函数\n\n\n\n\n\n\n\nobfs4proxy源代码部分函数\nobfs4.go\n\nWrapConn()  调用了serverHandshake()，不管返回什么错，都closeAfterDelay()。  \n\nserverHandshake()  新建服务端握手，设置基准超时时间。  然后按能读取的最大长度（8192）设置缓冲区，读取收包，保存收包内容，接下来parseClientHandshake()解析内容。  如果解析错误是ErrMarkNotFoundYet，继续读包，其他错误则函数返回错误。  解析正常则清空缓冲区。\n\n\n\nhandshake_ntor.go \n\nparseClientHandshake()  对于接收内容过少&#x2F;接收内容长度未达上限时，或找不到MarkMAC，准备了ErrMarkNotFoundYet的错误处理，可以返回继续读。  其他错误都关闭连接。找不到markMAC&#x2F;HMAC&#x2F;包长度不合规（有握手中不需要的数据），返ErrInvalidHandshake。  重放，返ErrReplayedHandshake。  计算验证不通过，返ErrNtorFailed。\n\ncloseAfterDelay()  closeAfterDelay()被修改，修复了因阈值产生FIN和RST的漏洞。旧版本会在延迟30s&#x2F;接收一定长度数据后终止连接，新版本都是延迟30s终止连接。  \n\nSetReadDeadline()  开始读数据30s后，再有数据进入也返回超时错误，并终止连接。（论文里说有随机延迟，我没找到）\n\n\n\nobfs4proxy.go \n\nserverHandler()  调用WrapConn()，如果返回错误，在日志中记录握手失败。  \nserverAcceptLoop()  让服务器循环开启与客户端的握手，调用serverHandler()。\n\n\n\n"},{"title":"Hello World","url":"/2026/01/08/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"【学习记录】六个RAT（远控木马）协议的通信特征（Gh0st, darkcomet, XtremeRAT, QuasarRAT, GreameRAT, njrat）","url":"/2026/01/08/rat/","content":"1 Gh0st1.1 基本情况Gh0stRAT最初由C.Rufus团队开发，客户端以服务的形式运行，可以随系统自启动，并通过隐藏文件和进程的方法躲避杀毒软件的检测。主要包括文件管理、系统信息收集、进程管理、屏幕截图、远程控制等模块，另外具有窃取密码、捕获网络流量和执行远程CMD命令的能力。通常通过电子邮件附件、恶意网站或软件漏洞传播。\n该木马于2009年被初次发现。其3.6版本的源代码在互联网上免费开源，因此备受欢迎，很多被修改的变种都由此而来，如大灰狼。2018年监测到Iron Tiger组织在攻击活动中使用Gh0stRAT变种，2021年监测到Gh0stRAT变种通过虚假Telegram安装程序在用户计算机上植入后门。\n1.2 基本特征\nTCP传输，默认监听端口为80，常见于8000、443 端口，默认伪装为 Microsoft Device Manager 服务\n数据(payload)头用明文显示magic number。如：Gh0st、GOLDt、HEART、Level、BeiJi\n固定的magic number会暴露自身版本信息\n对一些协议规范外的非法请求也会发出响应，如GET / HTTP/1.0\\r\\n\\r\\n\n缺少有效的包校验手段\n没有合理的会话管理机制\n源代码中，负责通信的发包方法是m_iocpServer()，Gh0stRAT虽然有多个变种，但此方法为各内核中核心的部分，通常不被修改，各变种有一个统一的通信特征。\n\n1.3 通信特征环境搭建参考：gh0st3.6 + vc6.0 + windows xp编译过程\n被控端发起请求信息\n\n整个通信过程中，用于传输数据的流量包的TCP标志位均包括PSH。在Gh0stRAT的握手中，被控端首先发起TCP连接请求。经过三次握手建立TCP连接后，被控端发送以”Gh0st\\xae\\x00\\x00\\x00\\xe0\\x00\\x00\\x00\\x78\\x9c“为前缀，包含经编码混淆后的自身系统信息的payload供上线。\n\n主控端响应\n\n主控端收到上线信息后，响应表示确认的流量包，Payload中同样以“Gh0st \\xae\\x00\\x00\\x00\\xe0\\x00\\x00\\x00\\x78\\x9c”为前缀。第14-15字节“\\x78\\x9c”为zlib的压缩头部，在Gh0st通信包中位置固定，见Gh0st大灰狼RAT家族通讯协议分析。\n2 DarkcometRAT2.1 基本情况DarkcometRAT在2008年由Jean-Pierre Lesueur开发，又称“暗黑彗星”，除了远控木马常见的加密和混淆技术外，还带有rootkit功能，允许在系统中隐藏自身存在。2012年，木马作者停止了对于这款木马的更新，最新版本停留在5.4.1。\n现在活跃的木马基本使用动态域名作为服务器域名，以“ddns.net”和“duckdns.org”为主，占比超过了50%。在腾讯反病毒实验室近年某月的威胁情报态势报告中发现，Darkcomet是该月使用最多的恶意网络协议，单日峰值达3000个。\n2.2 基本特征\nTCP传输，默认监听端口为1604\nRC4算法对通信流量进行加密和解密，主控端和被控端需要使用相同的密钥接受、发送信息\n使用预定义的命令字进行通信，参数之间用“|”隔开\n\n主控端发送“IDTYPE”命令字\n\n\n涉及传输数据的流量包的TCP标志位均包括PSH\n\n2.3 通信特征完成TCP三次握手后，主控端会用预先设定的密钥，发送经RC4算法加密后的命令字“IDTYPE”。\n默认密钥与版本有关，均形如“#KCMDDC𝑥#-8900123456789”， 𝑥为版本号，其中“0123456789”为用户可更改字段。\n具体对应如下表所示：\n随后被控端响应命令字“SERVER”密文，主控端接收后响应命令字“GetSIN”请求被控端主机信息并附带接收信息的数据库的IP地址，被控端接收后响应自身信息，完成Darkcomet握手。 \n2.4 平台对比shodan：搜索darkcomet，结果多在1604默认端口，且匹配响应均为V5的#KCMDDC5#-890密钥对应密文。360：多在3333端口，都是12位数时间戳，次多的6666端口，响应多为”000000009002”，应是误报，也包含shodan上的结果（都归在了“应用：darkcomet远控软件”里，此分类没有误报），同时还有“应用：darkcomet rat”分类，包含匹配时间戳的误报，猜测匹配规则是^[0-9A-F]{12}$。fofa：跟360类似。nmap：匹配规则也是^[0-9A-F]{12}$。(来源：darkcomet客户端与主控端进行tcp握手后，主控端会用预先设定的密钥，发送rc4算法加密后的命令字’IDTYPE’，默认密钥与版本有关。rc4加密后的密文长度为12位，由0-9和A-F构成。)\n3 njRAT3.1 基本情况njRAT，别名Bladabindi，于2013年首次被发现，使用.NET框架开发。2016年10月，Softpedia 报告称某破解版VMware下载会通过pastebin下载安装njRAT，若终止进程将会使计算机崩溃。2023年1月，木马病毒在中东地区扩散，攻击者使用.cab文件进行“政治对话”，实际在打开运行后会启动一个.vbs脚本，从云上下载njRAT安装到本地。\n3.2 基本特征\nTCP传输， 0.6.4版本的默认监听端口为1177，不同版本的默认端口不同\n涉及传输数据的流量包的TCP标志位均包括PSH\n参数之间用|’|’|隔开\n\n3.3 通信特征①client-&gt;server：上线被控端主动向主控端发起TCP连接，TCP三次握手完成后，发送自身信息以完成上线。参数之间用“|’|’|”隔开，后缀的关键字为“[endof]”。\n“lv”：命令字；“SGFjS2VkXzVDNjBFQUYz”：经base64编码后的被控端名称，即图中的“Name”；“WIN-GH46O995DIB”、“ win7”：被控端系统信息，对应图中 PC、user；“ 2023-02-21”：客户端安装时间，对应图中 Install Date；“\\x57\\x69\\x6e\\x20\\x37\\x20\\xbc\\xd2\\xcd\\xa5\\xc6\\xd5\\xcd\\xa8\\xb0\\xe6\\x20\\x53\\x50\\x31\\x20\\x78\\x36\\x34”：被控端操作系统名，对应图中“Operating system”；“No”：表示摄像头状况，这里没有，对应图中“Cam”；“0.6.4”：njRAT版本，对应图中“Ver.”；“5q2j5Zyo5o2V6I63IEFkYXB0ZXIgZm9yIGxvb3BiYWNrIHRyYWZmaWMgY2FwdHVyZQ&#x3D;&#x3D;”： base64 编码后的被控端活动窗口名，这里是“正在捕获 Adapter for loopback traffic capture”，为 Wireshark的窗口，对应图中“Active Window”。 \n通信流量捕获：server端控制台：②server-&gt;client：主控端响应“CAP|’|’|”， 表示捕获受害主机画面。 ③client-&gt;server： 被控端发送经编码的屏幕截图信息。 ④server-&gt;client：主控端发送关键字“P”保持连接，接下来重复此行为。⑤client-&gt;server：被控端响应经base64 编码后的活跃窗口名，这里为 njRAT的窗口，同时响应关键字“P”保持连接，接下来重复此行为。\n4 GreameRAT4.1 基本情况GreameRAT公布于2012年，来源于摩洛哥，使用Pascal语言开发， Delphi的unicode版本编译，同样具有模块化体系结构，允许攻击者根据自身需要添加或删除功能。\n4.2 基本特征GreameRAT 使用 TCP传输，除 1.9版本外，其余默认监听端口均为777、888、999，1.9版本的默认端口仅有999。被控端和主控端握手通信中包含数据交换的流量包，其 TCP 标志位均包括PSH，其中密钥为默认的“123456”。\n4.3 通信特征在 GreameRAT 握手中，被控端首先发送包含密钥长度n的数字，在测试环境中，发现25为固定常数，25+n即为发送的数字，在本次握手中为31，以“\\x7c\\0a”为后缀。被控端紧接着发送与密钥有关的校验数据。只有当两个数据都正确，主控端才会依次响应“\\x20\\x0d\\x0a”表示接收，以及后缀为“###@@@”的数据，完成握手。另外发现，若被控端除发送正确校验数据外，还发送了其他数据，主控端则会响应“tentarnovamente|”，是葡萄牙语的“tentar novamente”，意为重试。 \n5 QuasarRAT5.1 基本情况QuasarRAT 由 github 用户 MaxXor 采用 C#开发，首次公开于 2014年 7月，曾名“xRAT”，主要针对 Windows 操作系统，采用计划任务和注册表项维持自身持久存在。2018年2月，研究人员观察到一起通过恶意RTF文件分发QuasarRAT 作为最终有效载荷的攻击活动；2019年5月，enSilo观察到APT10使用PlugX 和 QuasarRAT 对东南亚政府和私人组织发起攻击。除此之外，著名的 APT攻击组织 “摩诃草”也曾长期使用此工具。\n5.2 基本特征QuasarRAT 使用 TCP 传输，常见监听端口为 5678，与数据传输相关的流量包中，TCP标志位均包括PSH。\n5.3 通信特征被控端主动向主控端发起 TCP连接，成功完成TCP连接后，主控端依次发送两个响应：“RPCMethod: preinstall”是 QuasarRAT 的命令，用于在目标主机上预安装Quasar客户端，是QuasarRAT主控端区别于其他端口服务的通信特征。\n6 XtemeRAT6.1 基本情况XtemeRAT发布于2010年，使用Delphi的Unicode版本开发，在GitHub 平台上开源，主要支持功能有文件与进程管理、键盘记录、服务管理和注册表管理。曾被北非狐（APT-C-44）组织用于针对阿拉伯语地区的攻击中。\n6.2 基本特征XtremeRAT使用 TCP传输，默认监听端口为80、81、82，默认密码为1234567890。\n6.3 通信特征被控端主动发起 TCP握手，完成 TCP三次握手建立连接后，被控端首先发送版本信息“myversion|3.2”。主控端回复第一个响应“X\\n\\r”，作为响应前缀，是XtremeRAT的通信特征。着主控端回复第二个响应，payload 中第 1-8 字节为密钥，在此例中密码为1234，第9-16字节为zlib压缩文件大小，此例中消息长度为152字节，均为小端序表示，第17-18字节为zlib指示符“\\x78\\x01”，在XtremeRAT通信中固定。\n6.4 尝试编译源代码（没完成，后来找到了exe）\n在delphi2010安装virtual tree view，将文件夹复制到$(BDS)\\Components\\VST\ndelphi7上安装KOL unicode组件，或在delphi2010上安装“MirrorKOLPackageD12.dpk”。执行正常KOL安装，然后获取Unicode版本文件并替换。感天动地，把那串乱码删掉就能装了\n创建项目：\n\n\n打开delphi7并转到：文件|新建|其他\n选择“向导”选项。将有一个KOL调色板。\n我做了一些修改，只能用作UNICODE，也就是说，不要在项目中使用“ansi”。\n打开文件“XtremeRAT.rar Components”并将数据复制到文件夹“$（BDS）\\Components\\”\n\n\n在delphi 2010中安装TMS组件\ndelphi2010|| Options | Environment Options | Delphi Options | Library - Win32 |\n\n$(BDS)\\Source\\Indy\\indy10\\System$(BDS)\\Source\\Indy\\indy10\\Core$(BDS)\\Source\\Indy\\indy10\\协议$(BDS)\\Components\\TMS\n\n安装AlphaControls.7.26组件，安装后将文件复制到$(BDS)\\Components\\AlphaControls\\D2010文件夹，然后转到delphi 2010中的工具选项|选项|环境选项| delphi选项|库-Win32|$（BDS）\\Components\\AlphaControls\\D2010\n\n"}]