<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2026/01/10/lzr/"/>
    <url>/2026/01/10/lzr/</url>
    
    <content type="html"><![CDATA[<p>title: 【论文阅读】《LZR: Identifying Unexpected Internet Services》笔记与思考</p><h1 id="论文原文与资料"><a href="#论文原文与资料" class="headerlink" title="论文原文与资料"></a>论文原文与资料</h1><p><a href="https://github.com/stanford-esrg/lzr">源代码</a><br><a href="https://data.esrg.stanford.edu/study/lzr">数据</a><br><a href="https://lizizhikevich.github.io/assets/papers/lzr.pdf">原文</a><br><a href="https://www.usenix.org/system/files/sec21_slides_izhikevich.pdf">PPT</a><br><a href="https://www.usenix.org/conference/usenixsecurity21/presentation/izhikevich">演讲</a>（youtube）</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>中文友好的《LZR: Identifying Unexpected Internet Services》（LZR：发现预期外的网络服务）论文阅读笔记。含有大量原文机翻和概括，斜体字为我的补充。</p><h1 id="研究要点"><a href="#研究要点" class="headerlink" title="研究要点"></a>研究要点</h1><ul><li>调查了网络中服务的部署位置，评估部署在意外端口上服务的安全态势。</li><li>过去的扫描假设服务部署在常见端口上，忽略了意外服务端口的扫描。响应SYN扫描的主机未完成应用层握手，或许服务被隐藏或防火墙阻止进一步交互。</li><li>根据在非预期服务端口上未完成应用层握手的行为，跟踪到防火墙和中间件，评估防扫描的有效性。</li><li>发现由于服务运行在意外端口，L7握手需要预先建立秘密协议握手和确认每个端口上的数据。部署在意外端口上服务的安全性较差，如一些物联网设备。</li><li>用一个数据包对88%的可识别服务进行指纹识别，五次握手识别99%的可识别意外服务。</li><li>过滤响应良好，返回SYN-ACK但不能完成应用层握手的主机来提速。</li></ul><h1 id="找到真正的TCP服务"><a href="#找到真正的TCP服务" class="headerlink" title="找到真正的TCP服务"></a>找到真正的TCP服务</h1><p>TCP活动不能表明有应用层服务，因为存在安全防火工具如防火墙和中间件。</p><h2 id="L4和L7的活性"><a href="#L4和L7的活性" class="headerlink" title="L4和L7的活性"></a>L4和L7的活性</h2><p>确认响应SYN-ACK包的主机是否完成常见端口对应服务的应用层握手。先用Zmap发SYN包，再用ZGrab尝试应用层握手。</p><p>结果相当一部分响应tcp的主机未完成L7握手，在常见端口上最有可能完成应用层握手，稀有端口上少有。</p><p>下面通过分析两个扫描阶段的状态变化来分析应用层无响应。</p><h2 id="连接回避"><a href="#连接回避" class="headerlink" title="连接回避"></a>连接回避</h2><p>防火墙如果无差别都伪造端口开放包的话，会影响正常用户的使用。所以防火墙需要按照某种规则来判断是否伪造响应，常见有将大量发送请求包的IP拉入黑名单。</p><p>在使用ZGrab进行TCP握手中，部分端口不响应SYN-ACK，可能是网络故障、DHCP中断或阻塞了扫描器。使用另一个未连接过主机的IP来扫一个随机的临时端口以确认是否存在连接回避，发现有70%回应了这个未连接过的IP，也就是此前的IP被回避了。在回避的IP块上，40%的主机回避了&#x2F;32子网块，10%回避&#x2F;24，最大的一个是墨西哥的ISP Alestra Net (ASN 11172)，回避了&#x2F;20。</p><p>对于被认为是恶意的IP，网络硬件（<em>如路由器</em> ）和主机软件（<em>如Snort</em>）会回避连接或动态阻塞。这些方法阻止了扫描者使用单个IP扫描网络，转而使用多个IP去到达目的主机，提高扫描者攻击的难度。通过比较单个源IP和多个源IP的扫描结果，发现会避开连接的主机并没有提供合法服务。如果扫描中能有效过滤，在研究中就可以安全地忽略掉它们。</p><h2 id="有TCP响应的主机会说TCP吗"><a href="#有TCP响应的主机会说TCP吗" class="headerlink" title="有TCP响应的主机会说TCP吗"></a>有TCP响应的主机会说TCP吗</h2><p>在使用ZGrab进行第二次握手时，有96%的端口服务没有完成应用层握手并返回SYN-ACK。接下来探讨主机是否进入交换应用层数据的状态，或者在发送一个SYN-ACK后就停止响应。下图表示扫描器如何根据捕获的数据来推断服务器状态。要进入establish状态，服务器只需要发送一个SYN-ACK。一旦客户端发送ACK，就可以正常传输数据，数据量在服务器的SYN-ACK包中的window size指定。</p><p>服务器可以在SYN-ACK中响应一个零窗口，当服务器准备接受数据时，客户端会发送后续ACK报文进行探测。图中ACKNOWLEDGE DATA定义为服务器允许客户端发送数据并确认客户端数据的状态。</p><p>ACCEPT DATA为捕获服务器是否准备好接收数据，到达此状态的服务器将保持TCP连接打开足够长的时间以接受数据并确认。这两个状态用于区分建立的连接是否能交换数据。</p><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110233036206.png"><br><small>图1 握手过程</small></p><p>基于ZGrab开发一个新扫描器建立TCP连接，发送两个换行符，推断服务器TCP状态。</p><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110233045683.png" title="具体算法"><br><small>图2 具体算法</small></p><p>通过扫描随机端口和IP地址后，发现16%常见端口和40%稀有端口上的服务无法进入ACKNOWLEDGES DATA状态。</p><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110233049700.png"><br><small>图3 实验结果</small></p><p>图a 在有TCP响应的主机中，只有SYN-ACK响应和到达ACKNOWLEDGE DATA状态的端口占比<br>图b 返回了SYN-ACK主机无法进入ACKNOWLEDGE DATA状态的原因</p><h2 id="零窗口DDOS防护"><a href="#零窗口DDOS防护" class="headerlink" title="零窗口DDOS防护"></a>零窗口DDOS防护</h2><p>在不接受数据的服务中，13%的常见端口服务和26%稀有端口返回零窗口（<em>nmap中若使用window扫描，会认为零窗口是关闭的端口</em>）的TCP包并且不增加窗口值来主动阻止客户端发送数据。在所有扫描的端口中，99.94%返回零窗口的主机不会增加窗口值，90%对二次发送的探针不响应，10%复位连接。这些行为基于网络或主机而不是服务。</p><p>其中99%的主机只要有一个端口返回了零窗口，同主机的其他端口也会返回零窗口。如果一个主机响应中从不增加窗口大小，那么这个主机可能永不响应。在juniper的安全服务网关代理中，使用这种方法来防止基于网络的SYN cookie的ddos攻击。响应零窗口的SYN-ACK报文，客户端发送ACK完成三次握手后，防火墙发送SYN包到墙后的服务器已建立连接。期间与客户端保持零大小的TCP窗口，中间件阻止了客户端向墙后服务器发送数据。</p><p>零窗口SYN-ACK部署在整个子网中，90%具有零窗口SYN-ACK的IP在大于&#x2F;24的子网中进行。佛罗里达州管理服务部发出了全网16%的零窗口SYN-ACK，并占随机端口上所有SYN-ACK的3%。跟之后的RST相比，SYN-ACK的TTL始终近一跳，表明是网络设备发出的。</p><h2 id="握手时中断连接"><a href="#握手时中断连接" class="headerlink" title="握手时中断连接"></a>握手时中断连接</h2><p>除了指定零窗口外，每个端口上有2%的主机从不确认数据（acknowledge data），尽管客户端返回了ACK，也不能完成三次握手。在重传7、8次SYN-ACK后推断服务器不会到达establish状态。不仅是TCP栈，在MCI通信服务下，在4567端口上重传SYN-ACK的IP在别的端口也会有同样的行为。真实服务响应的TTL是重传SYN-ACK的两倍以上，表明中间件选择性地丢包。</p><p>在握手过程中中断连接时防御行为，是ISP保护用户的方式，CenturyLink (AS 209)、Frontier Communications (AS 5650)和MCI Communications Services (AS 701)将入站流量丢弃到4567&#x2F;TRAM post-SYN端口。韩国电信(AS 4766)和Axtel (AS 6503)占中断在7547&#x2F;CWMP端口上的连接的73%。在常见端口上很少出现这种情况，只有5%的响应TCP的主机不接受数据并中断了80端口上的连接。</p><h2 id="重置连接"><a href="#重置连接" class="headerlink" title="重置连接"></a>重置连接</h2><p>73%常见端口和34%稀有端口上不接收数据、不能到达ESTABLISH状态的服务会在客户端完成三次握手后立刻重置连接。根据RFC793，如果服务器不想与客户端通信，服务器应该在客户端确认SYN-ACK后关闭TCP连接。这是DenyHosts防火墙返回给扫描器的方式。运行在SSH的主机上发生阻塞比HTTP更频繁。类似发送零窗口的网络，这种行为也是由于DDOS保护引起的。</p><p>为了防止SYN洪水攻击，中间件会代表服务器回传一个SYN-ACK，随后在客户端完成三次握手后与服务器建立连接。如果服务器拒绝连接，中间件将终止客户端的连接。Cisco IOS-based routers使用了这个方案。</p><p>主机关闭常见端口上连接的可能性增加了20%，由于谷歌负载均衡器附带的标准防火墙策略默认情况下接受这些端口上的通信，以便能执行服务健康检查，并在端口关闭时依赖后端的虚拟机重置连接。</p><h2 id="握手后的动态阻塞"><a href="#握手后的动态阻塞" class="headerlink" title="握手后的动态阻塞"></a>握手后的动态阻塞</h2><p>许多主机根本不承认所有数据，也不会回应后续握手。<br>为了区分是握手后避开扫描器和根本不承认数据的主机，我们同时使用初始连接的源IP和一个新IP去与初始回应了，但又不承认数据的主机进行L7握手。98%的主机回应了新IP，表示它们阻塞了之前传入的连接。这种动态阻塞的行为只发生在三次握手之后，不同于2.2中的连接回避。最大的握手后动态阻塞网络是Coming ABCDE HK (AS 133201)，占所有握手后阻塞的ip的48%。</p><p>其他无法确认数据的主机没有执行动态阻塞，因为它们在实际握手之后不会响应任何东西，但始终响应所有扫描。Vodaphone (AS 133612)和Webclassit (AS 34358)在所有扫描端口上都有这种行为，并且占所有ip的66%。且TTL值不匹配，表明存在中间件。</p><h2 id="中间件的防护能力"><a href="#中间件的防护能力" class="headerlink" title="中间件的防护能力"></a>中间件的防护能力</h2><p>动态阻塞，即在不确认数据的情况下完成握手，是降低扫描速度最有效的方法，该技术通过不接收扫描器的ACK来使扫描器超时。零窗口SYN-ACK也会导致超时，但零窗口很容易过滤。握手后关闭连接也只会导致可忽略不计的减速。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SYN-ACK不能表示服务是否存在。16%常见端口和40%稀有端口上的服务都被中间件保护，不接受数据。下面研究为什么使用TCP的主机不总是完成L7握手。</p><h1 id="应用层服务部署"><a href="#应用层服务部署" class="headerlink" title="应用层服务部署"></a>应用层服务部署</h1><p>上节研究L4响应服务，不与L7服务通信，是由于dos和扫描保护。排除了28%伪服务后（<em>怎么排除的见3.1</em>），发现常见端口上27%的服务和稀有端口上63%的服务没有运行预期的应用层协议。本节分析完成意外应用层握手或承认数据，但不是任何可识别的应用层协议服务。可识别的部署在意外端口上的服务占比很大，按照iana分配的端口只占很少一部分，只有6.4%TLS服务在443端口上运行。</p><h2 id="找到意外服务"><a href="#找到意外服务" class="headerlink" title="找到意外服务"></a>找到意外服务</h2><p>扫描部分IP，对于每个响应服务，首先使用预期的协议进行L7握手，失败时再使用30种协议扫描器进行后续握手。98%的IP提供不到4个无法识别的服务，2%的IP在超过6万个端口上提供无法识别的服务。在稀有端口上，大约75%无法识别的服务都是由几乎每个端口上都有无法识别服务的主机提供的。那些主机之所以在大多数端口上都有无法识别的服务，是因为一些网络会将所有流量丢弃到对安全敏感的端口。在所有端口返回SYN-ACK响应最多的前50个网络中，28%的网络将所有流量丢弃到445端口，10%网络丢弃到23端口。几乎每个端口上都有无法识别服务的主机集中在少数网络中。</p><p>另外，在基于RST指纹的F5 Big-IP防火墙中，由于配置防火墙时使用了通配符或防火墙的SYN-cookie缓存过载，IP会在每个端口上响应。可以通过检查主机是否承认5个随机端口上的数据来识别排除这些主机。过滤后平均有10%的常见服务和25%的稀有服务在过滤后仍然无法识别(<em>即，对30次握手中的任何一次都没有回应</em>)。</p><h2 id="意外服务的特征描述"><a href="#意外服务的特征描述" class="headerlink" title="意外服务的特征描述"></a>意外服务的特征描述</h2><p>常见端口上通常运行预期的协议服务，在80端口上大多数意外服务是基于tls的。</p><h2 id="意外服务的安全性"><a href="#意外服务的安全性" class="headerlink" title="意外服务的安全性"></a>意外服务的安全性</h2><p>大量物联网设备占用非标准端口45，但研究上很多只研究标准端口（14、20、27、55、62、71）通过手动识别属于物联网制造商的服务器证书，我们发现物联网接口在意外端口上广泛存在;意外端口上50%的TLS服务器证书属于物联网设备，而这些TLS属于物联网设备的可能性是端口443的5倍。</p><p>例如，韩国电信8000&#x2F;TLS中35%是icctv设备(即监控摄像头)，80&#x2F;TLS中38%是华为网络节点，分布在1%的国际网络中。在韩国网络中，8443端口上大约5%的TLS属于Android电视，至少20%属于路由器。</p><p>未分配的端口也包含更多的TCP&#x2F;UPnP设备。例如，49152端口(主要在拉丁美洲和亚洲电信)上的TCP&#x2F;UPnP设备数量是80端口的12倍，58000和30005端口的数量是80端口的2倍。</p><p>未分配端口上的TLS服务拥有已知私钥证书的可能性是分配端口上的1.71倍。在扫描未分配的端口时，我们发现已知私钥的证书数量是以前工作[32，36中报告的两倍多。例如，端口8081上40.2%的TLS主机是阿根廷电信（AS 10481和10318）中使用相同OpenSSL测试证书和已知私钥的DOCSIS 3.1无线网关，端口58000上39%的TLS主机是使用相同自签名证书和已知私钥的Qno无线设备。在23%的扫描端口中，公钥比端口443上的公钥更容易共享（最多1.7倍）（例如，80&#x2F;TLS的共享可能性是1.5倍）。尽管如此，之前研究互联网上加密密钥的工作将分析限制在443&#x2F;HTTPS、22&#x2F;SSH、995&#x2F;POP3、993&#x2F;IMAPS和25&#x2F;SMTPS。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>很多流行协议是分布在全部65K端口上，而不是iana分配的端口上。</p><h1 id="高效识别服务"><a href="#高效识别服务" class="headerlink" title="高效识别服务"></a>高效识别服务</h1><p>之前对于L7握手，发送了30种握手（<em>探针</em>），本节讨论发送五种握手消息来发现99%可识别协议的意外服务。</p><h2 id="协议发现"><a href="#协议发现" class="headerlink" title="协议发现"></a>协议发现</h2><p>两个加速协议发现的方向：</p><ol><li>在大量协议上触发协议识别响应的方法</li><li>优化握手顺序以实现高效服务发现<ul><li>banner指纹识别。</li><li>最佳握手顺序。<br> IANA分配的端口和临时端口中，仅打开连接等待就可以识别超过一半的意外服务。对于IANA分配的端口，等待和发送TLS客户端Hello就能发现80%意外服务。临时端口中，等待和http发现83.4%的服务。</li></ul></li></ol><h2 id="L7过滤的影响（应用层指纹识别）"><a href="#L7过滤的影响（应用层指纹识别）" class="headerlink" title="L7过滤的影响（应用层指纹识别）"></a>L7过滤的影响（<em>应用层指纹识别</em>）</h2><p>无法识别所有服务的一个原因是，即使协议猜测正确，选择的握手参数可能被拒绝。（如：SNMP中，服务器先确认数据，然后发送TCP RST来拒绝第一个数据包中未指定正确community string的请求）这种L7过滤策略会导致服务端不向客户端发送任何数据，阻碍指纹识别工作吗？</p><p>实验：以PPTP为例，按照RFC2637，添加magic cookie（用于同步TCP数据流的待定常数）选项，一种请求中设置为0x1A2B3C4D，另一种设为0x11111111。标准中规定同步丢失就必须关闭控制连接的TCP会话，因此如果magic cookie不正确，发送数据给客户端的IP将会减少。实验结果如下图，可见握手参数确实对IP的响应有影响。<br><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110233136612.png" alt="image-20260110233136578"><br><small>图4 实验结果</small></p><p>响应式IP在收到GET请求后确认数据并关闭连接，阻碍扫描器将服务识别为HTTP。通过发送带有option的请求，72%的IP以501（<em>方法未实现</em>）响应，17%的IP以405（<em>方法不允许</em>）响应，确认了它们使用HTTP。专门响应options请求的IP不局限于某个特定网络，在5.3%AS上都有。但80端口对于带options和不带options的请求响应差异较小。</p><p>对于TLS，根据RFC8446，握手失败需生成错误消息，并在关闭连接前通知应用程序，但给出不兼容密码时，2.65%的IP将简单关闭连接，不出现任何应用层错误。如PPTP中错误的magic cookie将导致67.1%的IP不响应任何数据。主机根据options进行应用层过滤，不会向客户端发送任何数据，对于扫描器来说，难点在于猜测好的参数使主机返回正确响应。</p><p><em>（像是nmap扫udp端口中提到的探针不一定能使主机返回正确响应）</em></p><h2 id="握手顺序的影响（对应最佳握手顺序）"><a href="#握手顺序的影响（对应最佳握手顺序）" class="headerlink" title="握手顺序的影响（对应最佳握手顺序）"></a>握手顺序的影响（<em>对应最佳握手顺序</em>）</h2><p>类似于握手选项阻止服务器的响应，在正确的握手之前重复尝试错误的握手可能阻止识别服务。对于主机在收到错误的L7信息后是否会过滤或拒绝连接，用以下实验评估：向1%IPv4中所有IANA分配的端口发送连续的HTTP GET和TLS hello，比较发送预期L7数据后完成后续握手的主机数和发送错误L7数据后完成后续握手的主机数。</p><p>不同协议中，与直接扫描协议时发现的主机相比，发送错误L7数据会导致30%的后续握手失败。有些即使指纹识别成功，但后续握手无法完成。如向telnet服务器发送非telnet数据会导致17%的后续握手失败，65%返回TCP RST，35%不返回SYN-ACK。向TLS服务器发送HTTP GET会导致29%后续TLS握手失败，这种行为类似于Cisco IOS的Login Block功能，允许管理员在登陆失败后临时阻止与L7服务的连接。</p><p>这种现象往往出现在主机发送协议识别数据后，可能是因为这是主机第一次存储有关连接的服务器端的应用层状态，不会阻止指纹识别，仅在识别的数据发送到扫描器后，阻止后续握手。在指纹识别后等待一段时间再进行后续握手能大幅提高握手成功率，99%的主机能在2分钟内进行指纹识别后完成后续握手。</p><p>发送错误的握手数据会导致一些服务无法完成后续握手，即使能完成指纹识别。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>L7扫描的限制是服务需要特定握手选项来响应。结果表明，许多主机响应错误的L7握手，发送有助于识别服务的数据，单个HTTP GET请求能检测到30种协议中的16个，99%意外服务在5次握手（<em>指的是五种不同的握手</em>）中识别，以此构建LZR。</p><h1 id="LZR"><a href="#LZR" class="headerlink" title="LZR"></a>LZR</h1><p>介绍LZR系统，有效识别互联网服务的扫描仪。可以与ZMap一起使用，或作为ZMap和应用层扫描仪（ZGrab）之间的插件，指示执行什么后续握手。</p><p>LZR优势在于，扫描中“快速失效“方法和识别协议的”一切指纹“方法，主要依赖于以下思路：</p><ul><li><p>忽略non-acknowledge的主机。</p><p>  40%的发送SYN-ACK的服务从不到达acknowledge data状态，这些服务不能完成L7握手，扫描期间可以忽略。Non-acknowledge的服务迫使状态扫描器打开操作系统套接字并等待超时。通过发送带有TCP握手的ACK应用层数据包来过滤出non-acknowledge的主机，类似ZMap的无状态SYN扫描。</p><p>  <em>附两个防端口扫描工具的原理：</em><br>  <em>1. 使用动态服务签名数据库生成假banner，基于服务签名正则表达式数据库动态生成有效服务签名来响应服务探测（如nmap -F -sV）</em></p><p>  <em>识别服务是否被模拟的方法只有通过协议探测（protocol probe）</em><br>  <img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110233144077.png" alt="image-20260110233144043"><br>  <small>图5 portspoof</small></p><p>  <em>2. <a href="https://qinqianshan.com/web/web_basic/tcp-scan/">防止使用TCP协议扫描端口</a></em><br>  <img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110233228457.png" alt="image-20260110233228412">        <img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110233237565.png"><br>  <em>判断non-acknowledge状态 我的总结：</em><br>  <em>1. 某IP响应了SYN-ACK，但只要有一个端口返零窗口，那么其他端口都返零窗口的概率极大。是防护策略。</em></p><p>  <em>2. 返回SYN-ACK但不确认随后发送数据的，是中间件（防火墙）代发的ACK，没有提供真实服务。</em></p></li><li><p>多listen<br>  每个端口多达96%的服务运行意外协议。在扫描的30个协议中，有8个协议是服务器首先发送数据，10个协议在发送错误的L7握手时发送指纹数据。</p><p>  通过始终等待然后对无效的服务器响应进行指纹识别，我们可以通过发送单个数据包来识别30个协议中的16个。扫描器只需执行最小的计算即可对服务进行指纹识别：来自服务器的第一个数据包识别正在运行的协议，该协议不需要完整的TCP&#x2F;IP堆栈。</p></li></ul><h2 id="5-1-扫描算法"><a href="#5-1-扫描算法" class="headerlink" title="5.1 扫描算法"></a>5.1 扫描算法</h2><p>LZR接收来自ZMap或(IP,port)元组的SYN-ACK数据包流进行扫描，在获得完整连接细节后，LZR首先过滤发送带有零窗口的主机（<em>按前面的研究，发现响应SYN-ACK的主机中，有99%只要在一个端口上返回零窗口，在其他端口上也返回零窗口</em>）。对于非零窗口，LZR将发送包含预期协议的第一个数据包握手数据的ACK包来继续连接，如果接收到任何类型的数据作为响应，将对数据进行指纹识别并关闭连接。</p><p>如果主机既不确认数据也不关闭连接，LZR将使用PUSH标志并重新传输数据（详见5.3）。如果主机不确认数据（<em>如在不确认的情况下从不响应或rst重置连接</em>），LZR会将主机标记为可能没有托管真正的服务，并不会继续进一步的连接尝试。</p><p><em>我部署了一个简单的接收到SYN就返SYN-ACK包的规则，使用nmap服务检测时也将PSH位置1，发了5次之后就断开连接，重新开启连接发下一个探针，很拖时间，最后得到结果是open，提供的服务不确定，打了个问号</em></p><p>如果主机确认了数据，但没有发送任何数据作为响应（<em>即服务器没有响应或之后立即关闭连接</em>），LZR会关闭连接，启动新连接，并发送下一个握手。</p><p>以上过程会持续进行，直到识别出正在运行的协议或没有其他握手能尝试。LZR还能通过同时向用户指定数量的随机临时端口发送SYN包，并检查SYN-ACK来选择性过滤几乎每个端口都响应的IP（见3.1）。</p><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110233427249.png" alt="image-20260110233427209"><br><small>图6 算法图示</small></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>LZR使用go语言开发，提供附录A中的所有协议握手，使用libpcap发送接收原始以太网数据包。能提供高效指纹服务，在扫描期间使用单个套接字，采用并继续无状态扫描器启动的连接，只需要发送和接收单个数据包来完成指纹服务，不需要完整TCP栈。</p><p>LZR将要测试的协议的命令行参数列表和来自ZMap或IP&#x2F;端口的SYN ACK流作为输入进行扫描。一部分例程发送包含握手消息的后续ACK包，并对响应进行指纹识别。容易向LZR中开始新的协议&#x2F;握手，每次握手都产生一个握手接口，指定要附加到ACK数据包的数据和在响应数据包中搜索什么来对协议进行指纹识别。</p><p>一旦接收到指纹数据，先检查数据是否与尝试协议的指纹匹配（在握手接口中指定）。如果不匹配，就会检查所有剩余的指纹是否匹配。使用LZR时要设置iptables规则防止Linux内核发送RST数据包以响应其接收的SYN-ack。否则，LZR无法采用并继续这些连接。</p><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><ul><li><p>性能评估。<br>  1）比较ZMap和LZR识别ZMap找到的端口上运行的服务。<br>  2）使用LZR作为ZMap和ZGrab之间的插件，指示ZGrab为ZMap找到的主机完成怎样的L7握手。<br>  LZR能比ZMap更快地过滤主机，在低命中率的临时端口上尤显优势。<br>  3）ZMap&#x2F;LZR+ZGrab离线扫描。首先，我们使用ZMap和LZR来识别使用已知协议的互联网主机，并将此阶段从我们的基准测试中排除。然后，在第二阶段，我们允许ZGrab全速处理服务。<br>  4）ZMap+LZR离线扫描。首先，我们使用ZMap找到候选服务，并将此阶段从我们的基准测试中排除。在第二阶段，我们测试了LZR能够以多快的速度全速运行指纹服务。<br>  我们使用每秒CPU周期计算ZGrab和LZR的运行时性能，因为这两种工具都受到CPU的限制：ZGrab完成完全握手（例如TLS的加密&#x2F;解密）和LZR的指纹（例如模式匹配）为每种工具创建了最大的性能瓶颈。</p></li><li><p>发现意外服务数量。<br>  可以识别意外服务，同时分析对ACK数据包中包含的数据响应来过滤出无响应的服务。LZR使用关键字指纹策略，通过仅使用预期的1-2次握手跨端口平均识别12个意外的唯一协议；仅通过一次预期握手，就可以发现在端口443上托管16个意外协议的130万个IP和在端口80上托管18个意外协议的238000个IP。</p></li><li><p>LZR在主机筛选上与仅使用ZMap和ZGrab相似。</p></li><li><p>LZR能在不完成L7握手下识别服务，提速。</p></li><li><p>对于很多服务都返回零窗口或不确认数据时，使用LZR检测服务比ZGrab速度显著提高。</p></li><li><p>节省带宽。<br>  原因：<br>  （1）LZR不尝试向零窗口主机重新传输ACK以检查窗口大小的增加</p><p>  （2）LZR不需要完成完整的L7握手。然而，使用ZGrab+LZR扫描，当大多数TCP响应主机服务于预期协议的端口时，由于LZR在重新尝试握手之前会为得到指纹发送至少一个额外的ACK（例如，对于80&#x2F;HTTP，LZR+ZGrab总共比ZMap+ZGrab多发送28%的数据包，即使LZR+ZGrab的运行速度比ZMap+ZGrab快1.2倍），因此发送的总数据包数也存在开销。</p></li></ul><h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><p>有几项研究指出L4和L7响应之间存在很大差异</p><ul><li><p>“tarpits“——试图欺骗网络扫描器的虚假服务，使用一些在连接开始时看到的中间件的相同技术。L. Alt, R. Beverly, and A. Dainotti. Uncovering network tarpits with degreaser. In 30th Annual Computer Security Applications Conf., 2014.<br>  与本文工作类似，他们考虑了不同点上的实时服务之间的关系，表明流行端口上的响应彼此相关。</p></li><li><p>S. Bano, P . Richter, M. Javed, S. Sundaresan, Z. Durumeric, S. J. Mur-<br>  doch, R. Mortier, and V . Paxson. Scanning the Internet for liveness.<br>  ACM SIGCOMM Computer Communication Review, 2018.<br>  LZR努力使用单个数据包来识别服务，减少了扫描稀有端口所需时间。</p></li><li><p>Klick等人（J. Klick, S. Lau, M. Wählisch, and V . Roth. Towards better Internet citizenship: Reducing the footprint of Internet-wide scans by topology aware prefix selection. In ACM Internet Measurement Conf., 2016.）<br>表明，许多IP地址空间不需要像<strong>Censys</strong>（Z. Durumeric, D. Adrian, A. Mirian, M. Bailey, and J. A. Halderman. A search engine backed by Internet-wide scanning. In ACM Conference on Computer and Communications Security, 2015.）]这样的服务持续扫描。</p></li><li><p><strong>ZMap</strong>： Z. Durumeric, E. Wustrow, and J. A. Halderman. ZMap: Fast Internet-wide scanning and its security applications. In 22nd USENIX Security Symposium, 2013. 快速互联网扫描及其安全应用。</p></li></ul><h1 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h1><p>很多响应syn扫描的主机有相当一部分从不完成应用层握手，在没有真正服务的情况下，大多数回复由中间件负责。且很多服务也处于意外端口上，与标准端口上的服务相比，意外端口上的服务安全性较弱。</p><p>LZR减少在稀有端口上执行应用层扫描所需时间，识别端口上运行的意外服务。用一个数据包识别16种协议和88%的可识别服务（指本系统能识别的服务），五次握手（最多传5种握手包）识别99%可识别服务。</p><p>仅仅使用前n个最流行的端口不足以评估哪些端口最有可能承载特定服务，因为HTTP和TLS的使用都比大多数协议广泛。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2026/01/10/obfs4_bridge_scan/"/>
    <url>/2026/01/10/obfs4_bridge_scan/</url>
    
    <content type="html"><![CDATA[<p>title: 【论文阅读】《Detecting probe resistant proxy》实验验证与分析</p><p>《detecting probe resistant proxy》论文阅读，对其中obfs4部分进行验证实验，并分析了obfs4proxy的部分源代码结构和函数、obfs4协议及其使用的加密方法和身份验证方式。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#1-%E5%BC%95%E8%A8%80">1 引言</a></li><li><a href="#2-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB">2 论文阅读</a><ul><li><a href="#21-%E6%8E%A2%E9%92%88%E9%80%89%E6%8B%A9">2.1 探针选择</a></li><li><a href="#22-%E5%AE%9E%E9%AA%8C%E6%95%B0%E6%8D%AE">2.2 实验数据</a></li><li><a href="#23-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C">2.3 实验结果</a></li><li><a href="#24-%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95">2.4 检测方法</a></li></ul></li><li><a href="#3-obfs4proxy%E5%88%86%E6%9E%90">3 obfs4proxy分析</a><ul><li><a href="#31-obfs4%E5%8D%8F%E8%AE%AE%E9%AA%8C%E8%AF%81%E9%80%BB%E8%BE%91">3.1 obfs4协议验证逻辑</a></li><li><a href="#32-obfs4proxy%E6%BA%90%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86%E7%BB%93%E6%9E%84">3.2 obfs4proxy源代码部分结构</a></li><li><a href="#33-obfs4proxy%E6%BA%90%E4%BB%A3%E7%A0%81%E9%83%A8%E5%88%86%E5%87%BD%E6%95%B0">3.3 obfs4proxy源代码部分函数</a></li></ul></li><li><a href="#4-%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E9%AA%8C">4 分析与实验</a><ul><li><a href="#41-%E8%AE%BA%E6%96%87%E7%AE%80%E6%9E%90">4.1 论文简析</a></li><li><a href="#42-%E5%AE%9E%E9%AA%8C%E9%AA%8C%E8%AF%81">4.2 实验验证</a></li><li><a href="#43-%E5%AE%9E%E9%AA%8C%E5%88%86%E6%9E%90">4.3 实验分析</a></li><li><a href="#44-%E5%AE%9E%E9%AA%8C%E7%BB%93%E8%AE%BA">4.4 实验结论</a></li></ul></li><li><a href="#5-%E5%90%8E%E7%BB%AD">5 后续</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99">相关资料</a></li></ul><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>当时看到这篇对代理检测的论文，对它的中文讨论较少，整理了自己阅读和实验后的笔记（关注于tor的obfs4），方便有需要的同学一起学习讨论。<br>（现在obfs4将要过时，推出了新的WebTunnels，但升级迭代仍需时间）</p><h1 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h1><h2 id="探针选择"><a href="#探针选择" class="headerlink" title="探针选择"></a>探针选择</h2><p>我们的攻击集中在这样一个观察上，即从不使用数据进行响应是互联网上的异常行为。通过发送由流行协议和随机数据组成的探针，我们可以从超过400k IP&#x2F;端口对的Tap数据集中的几乎所有端点（94%）获得响应。<br>对于不响应的端点，代理特有的TCP行为（如超时和数据阈值）与其他服务器相比存在不同。  </p><p>从6个基本探测开始：HTTP、TLS、MODBUS、S7、随机字节，以及连接后不发送数据的空探测。对于每个探测，我们都会记录服务器如何响应其响应的数据（如果有）、关闭连接的时间（如果有）以及如何关闭连接（TCP FIN或RST）。</p><ul><li><p>HTTP：对于HTTP，我们发送一个简单的HTTP&#x2F;1.1 GET请求，主机头为example.com。大部分服务器将响应重定向或错误页面进行响应。即使不是HTTP的服务器也可能使用其协议固有的错误消息对此探测作出响应。</p></li><li><p>TLS：我们发送一条TLS客户端Hello消息，该消息通常由Chromium版本71浏览器生成。这包括流行的密码套件和扩展，即使服务器不支持TLS，也应该响应TLS警报消息。</p></li><li><p>Modbus：Modbus通常用于监控和数据采集（SCADA）环境中的可编程逻辑控制器（PLC）和其他嵌入式设备。使用了ZGrab中定义的探针，它发送一个3字节的命令，从远程主机请求设备信息描述符。</p></li><li><p>S7:S7是西门子PLC设备使用的专有协议。再次使用ZGrab中定义的探针，该探针通过COTP&#x2F;S7协议发送设备标识符请求。</p></li><li><p>随机字节：不同数量随机字节的探测，服务器将解析失败，并以错误消息响应，或者以区别于代理服务器的方式关闭连接。</p></li><li><p>空探针：在连接后不发送数据。一些协议（如SSH）让服务器首先（或同时）与客户端通信。对于其他协议，当客户端发送了一些初始数据时，与不发送数据时相比，实现可能具有不同的超时。  </p></li><li><p>DNS AXFR：根据DNS规范构建了一个DNS AXFR（区域传输）查询探测。</p></li><li><p>STUN: 实现了一个基于ZGrab-Golang库的STUN探测，用于探测Cisco WebEx设备</p></li></ul><h2 id="实验数据"><a href="#实验数据" class="headerlink" title="实验数据"></a>实验数据</h2><ul><li><p>代理端点<br>从Tor的BridgeDB收集了20多个obfs4代理端点</p></li><li><p>非代理端点<br>使用ZMap的主动网络扫描和网络流数据的被动收集。<br>我们使用ZMap向每个TCP端口（0-65535）上的20000个主机发送一个SYN数据包，总共有13亿次探测。发现了150万个响应SYN ACK的端点，我们将其标记为ZMap数据集。<br>科罗拉多大学的10 Gbps网关中采样netflow数据来收集端点。在无网络审查国家中，绝大多数流量不包含代理，所以收集到的端点主要是其他服务。在3天的时间跨度内，从ISP收集了超过550000个服务器IP&#x2F;端口 的节点。其中，433286（79%）个主机接受了连接（使用一个TCP SYN-ACK响应），其余的大多数在尝试连接时只是超时。<br>后续扫描是在观察到连接后的几天内进行的，一些服务器可能在这段时间内移动了IP或离线。其次，服务器可能配置了防火墙，只允许从某些IP进行访问，可能会阻塞ZMap扫描主机。最终在这个数据集中捕获超过40万个发送数据的服务器。</p></li></ul><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>我们向190万个节点发送13个探测（第III-A节中的7个探测和6个随机数据范围为4KB-40KB的探测），并记录服务器是否和何时响应数据或关闭连接。如果服务器关闭，我们将记录它是否使用FIN或RST。如果服务器没有响应或关闭连接，我们将在300秒后超时，并将结果标记为超时。记录他们的关闭阈值。</p><p>由于抗探测代理从不响应数据，因此可以将响应的端点丢弃。在被动Tap数据集中，这排除了94%的主机，只留下26021个潜在代理。在ZMap数据集中，绝大多数主机对任何探测都没有数据响应，仅丢弃1.16%的端点 。</p><p>原因是ZMap识别的节点中，防火墙使用了chaff策略，仅在特定的子网上对SYN做出响应。42%的节点行为相同，不发送数据也不关闭与探测器的连接。将响应数据聚类（响应类型、响应字节数、连接关闭时间或超时时间） 在Tap数据集中，最流行的响应组包含3%的端点，似乎是Cloudflare网络中的TLS服务器（99.9％在具有端口443的端点上）。图2显示了ZMap和Tap数据集的不同响应集（按流行程度排序）的CDF，说明Tap数据集中有更大的多样性。前10个响应集占ZMap数据集中超过80%的端点，但只有13%的端点是在Tap中收集的。</p><h2 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h2><ol><li><p>缓冲阈值<br> 服务器将在接收到一定数量的字节后使用FIN关闭，并可能在接收到更高数量的字节之后使用RST关闭。代理服务的关闭阈值大多数是唯一的。<br> 考虑一个从客户端读取N个字节并尝试将其解析为协议头的服务器。如果解析失败（例如无效字段、校验和或MAC），服务器可以简单地关闭连接。<br> 如果客户端仅发送N−1字节，服务器可能会保持连接打开，并在尝试解析之前等待其他数据。  </p><p> obfs4握手长度可达8192字节，因此服务器在确定客户端无效并进入closeAfterDelay函数之前读取了这么多字节。此函数在随机延迟（30-90秒）后关闭连接，或在服务器启动时读取额外的N个字节（在0和8192之间随机选择的N个）后关闭。然而，这些读取都是使用1448字节的缓冲区完成的。这意味着，如果发送了$8192+N$字节，obfs4服务器将发送FIN，如果发送$8192 + N − ((8192 + N)mod 1448) + 1448$字节，则返回rst。是obfs4独有行为。  </p><p> <strong>论文作者与torproject交流研究成果后，obfs4proxy已于0.0.11版本修复关闭阈值的行为。</strong></p></li><li><p>超时时间<br>许多端点根据其接收的数据量具有不同的超时。<br>不确认数据的主机不是标准的TCP行为，我们会重传，代理不会有这种行为，不影响结果。  </p><p> <strong>修复关闭阈值，但仍能观察到超时行为。</strong></p></li><li><p>不响应任何探测是罕见的。</p></li></ol><h1 id="obfs4proxy分析"><a href="#obfs4proxy分析" class="headerlink" title="obfs4proxy分析"></a>obfs4proxy分析</h1><h2 id="obfs4协议验证逻辑"><a href="#obfs4协议验证逻辑" class="headerlink" title="obfs4协议验证逻辑"></a>obfs4协议验证逻辑</h2><h3 id="握手过程"><a href="#握手过程" class="headerlink" title="握手过程"></a>握手过程</h3><pre><code class=" mermaid">sequenceDiagram    Client-&gt;&gt;Server: SYN+ECN+CWR    Server--&gt;&gt;Client: SYN+ACK     Client-&gt;&gt;Server: ACK    Client-&gt;&gt;Server: PSH+ACK+data</code></pre><h3 id="data内容"><a href="#data内容" class="headerlink" title="data内容"></a>data内容</h3><p>涉及算法：curve25519</p><p>客户端及服务端都必须有自己的Keypair实例。根据curve25519包中的定义，PrivateKey在一定范围内随机生成。根据ECC算法，PublicKey可以通过调用curve25519.ScalarBaseMult()从私钥生成。  </p><p>Representative秘钥根据公钥生成，在需要的时候可以调用extra25519.RepresentativeToPublicKey()函数再次转换为公钥。Keypair的定义及初始化代码位于NewKeypair()函数中，该函数在ntor.go文件中定义。</p><p>用extra25519.go里的ScalarBaseMult()，根据privatekey生成public和representative。representative通过Elligator 2映射完成混淆，避免收集到相当数量的公钥后推断出加密算法。<br><a href="http://elligator.cr.yp.to/elligator-20130828.pdf">算法详细说明</a></p><p>客户端及服务端都应当保存好私钥，将公钥以Representative秘钥的形式发送给对方。Obfs4客户端的连接过程从握手报文开始，因此我们来看一下客户端的握手报文。该报文的整体结构如下所示：</p><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110231135876.png"></p><ol><li>Keypair.representative，其长度为20h字节。在服务器端，它可以作为还原客户端的公钥。（obfs4 bridge配置行）</li><li>使用随机字节的填充数据，其数据大小范围在4Dh至1FC0h之间，该填充数据会混淆握手数据包的大小，从而使其更难识别。</li><li>第一部分Keypair.representative的HMAC值。Obfs4使用SHA-256生成HMAC，长度为20h字节。Obfs4仅将前10h字节保留为HMAC，其余10h字节将被丢弃。  </li><li>Obfs4使用当前系统时间来计算UNIX Epoch时间（从UTC时间1970年1月1日星期四00:00:00开始）的小时值。计算数据包中前三个部分的HMAC值，加上（指拼接起来）字符串中的小时值。同样，其结果长度为20h字节，前10h字节作为数据包的第四部分。（防重放）</li></ol><h2 id="obfs4proxy源代码部分结构"><a href="#obfs4proxy源代码部分结构" class="headerlink" title="obfs4proxy源代码部分结构"></a>obfs4proxy源代码部分结构</h2><h3 id="common"><a href="#common" class="headerlink" title="common&#x2F;"></a>common&#x2F;</h3><p>  密码学、socks5等组件    </p><h3 id="internal"><a href="#internal" class="headerlink" title="internal&#x2F;"></a>internal&#x2F;</h3><p>  更新的混淆算法  </p><h3 id="obfs4proxy"><a href="#obfs4proxy" class="headerlink" title="obfs4proxy&#x2F;"></a><strong>obfs4proxy&#x2F;</strong></h3><p>obfs4proxy.go  主函数  </p><h3 id="transports"><a href="#transports" class="headerlink" title="transports&#x2F;"></a><strong>transports&#x2F;</strong></h3><p>包含meeklite、obfs2、3、4、 scramblesuit传输协议的实现   </p><ul><li><strong>obfs4&#x2F;</strong>  <ul><li>framing&#x2F; 数据帧的处理  <ul><li>handshake_ntor.go 完成obfs4握手，包括验证  </li><li>obfs4.go 握手相关函数</li></ul></li></ul></li></ul><h2 id="obfs4proxy源代码部分函数"><a href="#obfs4proxy源代码部分函数" class="headerlink" title="obfs4proxy源代码部分函数"></a>obfs4proxy源代码部分函数</h2><h3 id="obfs4-go"><a href="#obfs4-go" class="headerlink" title="obfs4.go"></a>obfs4.go</h3><ul><li><p>WrapConn()<br>调用了serverHandshake()，不管返回什么错，都closeAfterDelay()。  </p></li><li><p>serverHandshake()<br>新建服务端握手，设置基准超时时间。<br>然后按能读取的最大长度（8192）设置缓冲区，读取收包，保存收包内容，接下来parseClientHandshake()解析内容。<br>如果解析错误是ErrMarkNotFoundYet，继续读包，其他错误则函数返回错误。<br>解析正常则清空缓冲区。</p></li></ul><h3 id="handshake-ntor-go"><a href="#handshake-ntor-go" class="headerlink" title="handshake_ntor.go"></a>handshake_ntor.go</h3><ul><li><p>parseClientHandshake()<br>对于接收内容过少&#x2F;接收内容长度未达上限时，或找不到MarkMAC，准备了ErrMarkNotFoundYet的错误处理，可以返回继续读。<br>其他错误都关闭连接。找不到markMAC&#x2F;HMAC&#x2F;包长度不合规（有握手中不需要的数据），返ErrInvalidHandshake。<br>重放，返ErrReplayedHandshake。<br>计算验证不通过，返ErrNtorFailed。  </p></li><li><p>closeAfterDelay()<br><a href="https://gitlab.com/yawning/obfs4/-/commit/1a6129b66ff3e66c347b54fbae203c1c61d12d74">closeAfterDelay()被修改</a>，修复了因阈值产生FIN和RST的漏洞。旧版本会在延迟30s&#x2F;接收一定长度数据后终止连接，新版本都是延迟30s终止连接。  </p></li><li><p>SetReadDeadline()<br>开始读数据30s后，再有数据进入也返回超时错误，并终止连接。（论文里说有随机延迟，我没找到）</p></li></ul><h3 id="obfs4proxy-go"><a href="#obfs4proxy-go" class="headerlink" title="obfs4proxy.go"></a>obfs4proxy.go</h3><ul><li><p>parseClientHandshake()<br>对于接收内容过少&#x2F;接收内容长度未达上限时，或找不到MarkMAC，准备了ErrMarkNotFoundYet的错误处理，可以返回继续读。<br>其他错误都关闭连接。找不到markMAC&#x2F;HMAC&#x2F;包长度不合规（有握手中不需要的数据），返ErrInvalidHandshake。<br>重放，返ErrReplayedHandshake。<br>计算验证不通过，返ErrNtorFailed。  </p></li><li><p>closeAfterDelay()<br><a href="https://gitlab.com/yawning/obfs4/-/commit/1a6129b66ff3e66c347b54fbae203c1c61d12d74">closeAfterDelay()被修改</a>，修复了因阈值产生FIN和RST的漏洞。旧版本会在延迟30s&#x2F;接收一定长度数据后终止连接，新版本都是延迟30s终止连接。  </p></li><li><p>SetReadDeadline()<br>开始读数据30s后，再有数据进入也返回超时错误，并终止连接。（论文里说有随机延迟，我没找到）</p></li></ul><h1 id="分析与实验"><a href="#分析与实验" class="headerlink" title="分析与实验"></a>分析与实验</h1><h2 id="论文简析"><a href="#论文简析" class="headerlink" title="论文简析"></a>论文简析</h2><p>论文人工构造的obfs4决策树中，首先随机发送17k的数据，2s内返回RST则进入下一步，发送其他探针，30s–90s之内返回FIN，则为obfs4。17k数据是为了引发阈值问题，已被修复，但延时FIN的情况仍然存在。</p><p>论文中针对obfs4 bridge的实验数据过少，我决定自己实验验证。在测试了几个已知obfs4 bridge后，我发现巧合的，每一个bridge都有固定的超时时间。</p><p>猜想：每一个bridge都有固定的超时时间。（有可能bridge在重启服务后会改变？随机延时时间只生成一次？）<br>对6个已知obfs4 bridge进行测试，发送同样的data（重放tor浏览器发起的成功握手中的data），命中了验证不通过的错误，进入closeAfterDelay()。<br>对每个bridge发起两次握手。对于同一bridge，在两个不同ip客户端上，发起的两次握手均经过相同时间后返回FIN，时间均落在[30,90]s。 </p><h2 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a>实验验证</h2><ol><li><p>测试集：对<a href="https://github.com/scriptzteam/Tor-Bridges-Collector">测试集</a>进行验证过滤后，得到四百余存活服务。</p></li><li><p>判断条件：TLS和HTTP探针无响应，17k字节返回RST或超时时间（返回FIN）为[30,90]s。</p></li><li><p>实验结果：  </p><p>① 80%服务判断为obfs4 bridge。其中，50%返回RST，50%超时时间在范围内。<br>② 6%服务判断不为obfs4 bridge。<br>③ 10%服务无法确定，发17k字节立刻收到FIN，TLS和HTTP均超时。</p></li></ol><h2 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h2><ol><li>80%bridge服务命中判断条件，验证了判断条件可行。</li><li>6%服务中，发送TLS和HTTP均有回应，可探测出其他服务，应是提供的服务发生了变化，符合预期。</li><li>剩下10%服务，未命中判断条件，但是挑了几个，在tor浏览器中设置配置行后，可以作为bridge使用。发送20k字节后，50%返回RST。重放obfs4握手data之后，全部在[30,90]s内FIN。<br>猜测这些是已升级至新版本的bridge服务，重放握手数据后，则检验失败，进入延迟FIN函数。但是20k已经超过了论文所观察到的RST阈值，后来再发了30k，只有少数个响应RST。</li></ol><h2 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h2><ol><li>发送足够大的随机数据，马上返回RST（obfs4proxy 0.0.11版本已修复）  </li><li>发送符合握手长度数据，[30,90]s内返回FIN</li></ol><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>结合其他特征后，已实现主动收集方案。</p><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p><a href="https://gitlab.torproject.org/legacy/trac/-/issues/7349">torproject对于ORPort的讨论</a>(<a href="https://gitlab.torproject.org/tpo/core/tor/-/issues/7349">move to here</a>)<br><a href="https://jiangph2016.github.io/2020/04/07/detect-probe/">论文精读</a><br><a href="https://github.com/net4people/bbs/issues/26">论文讨论issue</a><br><a href="http://meetbot.debian.net/tor-meeting/2020/tor-meeting.2020-04-02-17.59.html">torproject会议记录</a><br><a href="http://meetbot.debian.net/tor-meeting/2020/tor-meeting.2020-04-02-17.59.log.html">torproject聊天记录</a>  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>【学习记录】六个RAT（远控木马）协议的通信特征（Gh0st, darkcomet, XtremeRAT, QuasarRAT, GreameRAT, njrat）</title>
    <link href="/2026/01/08/rat/"/>
    <url>/2026/01/08/rat/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Gh0st"><a href="#1-Gh0st" class="headerlink" title="1 Gh0st"></a>1 Gh0st</h1><h2 id="1-1-基本情况"><a href="#1-1-基本情况" class="headerlink" title="1.1 基本情况"></a>1.1 基本情况</h2><p>Gh0stRAT最初由C.Rufus团队开发，客户端以服务的形式运行，可以随系统自启动，并通过隐藏文件和进程的方法躲避杀毒软件的检测。主要包括文件管理、系统信息收集、进程管理、屏幕截图、远程控制等模块，另外具有窃取密码、捕获网络流量和执行远程CMD命令的能力。通常通过电子邮件附件、恶意网站或软件漏洞传播。</p><p>该木马于2009年被初次发现。其3.6版本的源代码在互联网上免费开源，因此备受欢迎，很多被修改的变种都由此而来，如大灰狼。2018年监测到Iron Tiger组织在攻击活动中使用Gh0stRAT变种，2021年监测到Gh0stRAT变种通过虚假Telegram安装程序在用户计算机上植入后门。</p><h2 id="1-2-基本特征"><a href="#1-2-基本特征" class="headerlink" title="1.2 基本特征"></a>1.2 基本特征</h2><ol><li>TCP传输，默认监听端口为80，常见于8000、443 端口，默认伪装为 Microsoft Device Manager 服务</li><li>数据(payload)头用明文显示magic number。如：Gh0st、GOLDt、HEART、Level、BeiJi</li><li>固定的magic number会暴露自身版本信息</li><li>对一些协议规范外的非法请求也会发出响应，如<code>GET / HTTP/1.0\r\n\r\n</code></li><li>缺少有效的包校验手段</li><li>没有合理的会话管理机制</li><li>源代码中，负责通信的发包方法是<code>m_iocpServer()</code>，Gh0stRAT虽然有多个变种，但此方法为各内核中核心的部分，通常不被修改，各变种有一个统一的通信特征。</li></ol><h2 id="1-3-通信特征"><a href="#1-3-通信特征" class="headerlink" title="1.3 通信特征"></a>1.3 通信特征</h2><p>环境搭建参考：<a href="https://blog.csdn.net/ll121221/article/details/80499645">gh0st3.6 + vc6.0 + windows xp编译过程</a></p><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230103033.png" alt="image-20260110230102985"></p><center><small>被控端发起请求信息</small></center><p>整个通信过程中，用于传输数据的流量包的TCP标志位均包括PSH。在Gh0stRAT的握手中，被控端首先发起TCP连接请求。经过三次握手建立TCP连接后，被控端发送以”<code>Gh0st\xae\x00\x00\x00\xe0\x00\x00\x00\x78\x9c</code>“为前缀，包含经编码混淆后的自身系统信息的payload供上线。</p><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230113559.png" alt="image-20260110230113520"></p><center><small>主控端响应</small></center><p>主控端收到上线信息后，响应表示确认的流量包，Payload中同样以“<code>Gh0st \xae\x00\x00\x00\xe0\x00\x00\x00\x78\x9c</code>”为前缀。第14-15字节“<code>\x78\x9c</code>”为zlib的压缩头部，在Gh0st通信包中位置固定，见<a href="https://www.freebuf.com/articles/paper/167917.html">Gh0st大灰狼RAT家族通讯协议分析</a>。</p><h1 id="2-DarkcometRAT"><a href="#2-DarkcometRAT" class="headerlink" title="2 DarkcometRAT"></a>2 DarkcometRAT</h1><h2 id="2-1-基本情况"><a href="#2-1-基本情况" class="headerlink" title="2.1 基本情况"></a>2.1 基本情况</h2><p>DarkcometRAT在2008年由Jean-Pierre Lesueur开发，又称“暗黑彗星”，除了远控木马常见的加密和混淆技术外，还带有rootkit功能，允许在系统中隐藏自身存在。2012年，木马作者停止了对于这款木马的更新，最新版本停留在5.4.1。</p><p>现在活跃的木马基本使用动态域名作为服务器域名，以“ddns.net”和“duckdns.org”为主，占比超过了50%。在腾讯反病毒实验室近年某月的<a href="http://221.5.97.116/dlied6.qq.com/invc/xfspeed/qqpcmgr/other/Habo-201606-ThreatIntelligence.pdf">威胁情报态势报告</a>中发现，Darkcomet是该月使用最多的恶意网络协议，单日峰值达3000个。</p><h2 id="2-2-基本特征"><a href="#2-2-基本特征" class="headerlink" title="2.2 基本特征"></a>2.2 基本特征</h2><ol><li>TCP传输，默认监听端口为1604</li><li>RC4算法对通信流量进行加密和解密，主控端和被控端需要使用相同的密钥接受、发送信息</li><li>使用预定义的命令字进行通信，参数之间用“|”隔开</li><li><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230127807.png"></li></ol><center><small>主控端发送“IDTYPE”命令字</small></center><ol start="4"><li>涉及传输数据的流量包的TCP标志位均包括PSH</li></ol><h2 id="2-3-通信特征"><a href="#2-3-通信特征" class="headerlink" title="2.3 通信特征"></a>2.3 通信特征</h2><p>完成TCP三次握手后，主控端会用预先设定的密钥，发送经RC4算法加密后的命令字“<code>IDTYPE</code>”。</p><p>默认密钥与版本有关，均形如“<code>#KCMDDC𝑥#-8900123456789</code>”， 𝑥为版本号，其中“<code>0123456789</code>”为用户可更改字段。</p><p>具体对应如下表所示： </p><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230134647.png"></p><p>随后被控端响应命令字“<code>SERVER</code>”密文，主控端接收后响应命令字“<code>GetSIN</code>”请求被控端主机信息并附带接收信息的数据库的IP地址，被控端接收后响应自身信息，完成Darkcomet握手。 </p><h2 id="2-4-平台对比"><a href="#2-4-平台对比" class="headerlink" title="2.4 平台对比"></a>2.4 平台对比</h2><p>shodan：搜索darkcomet，结果多在1604默认端口，且匹配响应均为V5的#KCMDDC5#-890密钥对应密文。<br>360：多在3333端口，都是12位数时间戳，次多的6666端口，响应多为”000000009002”，应是误报，也包含shodan上的结果（都归在了“应用：darkcomet远控软件”里，此分类没有误报），同时还有“应用：darkcomet rat”分类，包含匹配时间戳的误报，猜测匹配规则是<code>^[0-9A-F]{12}$</code>。<br>fofa：跟360类似。<br>nmap：匹配规则也是<code>^[0-9A-F]{12}$</code>。(来源：darkcomet客户端与主控端进行tcp握手后，主控端会用预先设定的密钥，发送rc4算法加密后的命令字’IDTYPE’，默认密钥与版本有关。rc4加密后的密文长度为12位，由0-9和A-F构成。)</p><h1 id="3-njRAT"><a href="#3-njRAT" class="headerlink" title="3 njRAT"></a>3 njRAT</h1><h2 id="3-1-基本情况"><a href="#3-1-基本情况" class="headerlink" title="3.1 基本情况"></a>3.1 基本情况</h2><p>njRAT，别名Bladabindi，于2013年首次被发现，使用.NET框架开发。<br>2016年10月，Softpedia 报告称某破解版VMware下载会通过pastebin下载安装njRAT，若终止进程将会使计算机崩溃。<br>2023年1月，木马病毒在中东地区扩散，攻击者使用.cab文件进行“政治对话”，实际在打开运行后会启动一个.vbs脚本，从云上下载njRAT安装到本地。</p><h2 id="3-2-基本特征"><a href="#3-2-基本特征" class="headerlink" title="3.2 基本特征"></a>3.2 基本特征</h2><ol><li>TCP传输， 0.6.4版本的默认监听端口为1177，不同版本的默认端口不同</li><li>涉及传输数据的流量包的TCP标志位均包括PSH</li><li>参数之间用<code>|’|’|</code>隔开</li></ol><h2 id="3-3-通信特征"><a href="#3-3-通信特征" class="headerlink" title="3.3 通信特征"></a>3.3 通信特征</h2><p>①client-&gt;server：上线<br>被控端主动向主控端发起TCP连接，TCP三次握手完成后，发送自身信息以完成上线。参数之间用“<code>|’|’|</code>”隔开，后缀的关键字为“<code>[endof]</code>”。</p><p>“lv”：命令字；<br>“SGFjS2VkXzVDNjBFQUYz”：经base64编码后的被控端名称，即图中的“Name”；<br>“WIN-GH46O995DIB”、“ win7”：被控端系统信息，对应图中 PC、user；<br>“ 2023-02-21”：客户端安装时间，对应图中 Install Date；<br>“\x57\x69\x6e\x20\x37\x20\xbc\xd2\xcd\xa5\xc6\xd5\xcd\xa8\xb0\xe6\x20\x53\x50\x31\x20\x78\x36\x34”：被控端操作系统名，对应图中“Operating system”；<br>“No”：表示摄像头状况，这里没有，对应图中“Cam”；<br>“0.6.4”：njRAT版本，对应图中“Ver.”；“5q2j5Zyo5o2V6I63IEFkYXB0ZXIgZm9yIGxvb3BiYWNrIHRyYWZmaWMgY2FwdHVyZQ&#x3D;&#x3D;”： base64 编码后的被控端活动窗口名，这里是“正在捕获 Adapter for loopback traffic capture”，为 Wireshark的窗口，对应图中“Active Window”。 </p><p>通信流量捕获：</p><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230145375.png" alt="image-20260110230145334"><br>server端控制台：</p><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230154725.png" alt="image-20260110230154682"><br>②server-&gt;client：<br>主控端响应“CAP|’|’|”， 表示捕获受害主机画面。</p><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230207088.png" alt="image-20260110230207059"><br> ③client-&gt;server：<br> 被控端发送经编码的屏幕截图信息。</p><p> <img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230214398.png"><br>④server-&gt;client：<br>主控端发送关键字“P”保持连接，接下来重复此行为。</p><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230222173.png"><br>⑤client-&gt;server：<br>被控端响应经base64 编码后的活跃窗口名，这里为 njRAT的窗口，同时响应关键字“P”保持连接，接下来重复此行为。</p><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230228551.png"></p><h1 id="4-GreameRAT"><a href="#4-GreameRAT" class="headerlink" title="4 GreameRAT"></a>4 GreameRAT</h1><h2 id="4-1-基本情况"><a href="#4-1-基本情况" class="headerlink" title="4.1 基本情况"></a>4.1 基本情况</h2><p>GreameRAT公布于2012年，来源于摩洛哥，使用Pascal语言开发， Delphi的unicode版本编译，同样具有模块化体系结构，允许攻击者根据自身需要添加或删除功能。</p><h2 id="4-2-基本特征"><a href="#4-2-基本特征" class="headerlink" title="4.2 基本特征"></a>4.2 基本特征</h2><p>GreameRAT 使用 TCP传输，除 1.9版本外，其余默认监听端口均为777、888、999，1.9版本的默认端口仅有999。被控端和主控端握手通信中包含数据交换的流量包，其 TCP 标志位均包括PSH，其中密钥为默认的“123456”。</p><h2 id="4-3-通信特征"><a href="#4-3-通信特征" class="headerlink" title="4.3 通信特征"></a>4.3 通信特征</h2><p>在 GreameRAT 握手中，被控端首先发送包含密钥长度n的数字，在测试环境中，发现25为固定常数，25+n即为发送的数字，在本次握手中为31，以“\x7c\0a”为后缀。</p><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230237568.png"><br>被控端紧接着发送与密钥有关的校验数据。 </p><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230241588.png" alt="image-20260110230241559"><br>只有当两个数据都正确，主控端才会依次响应“\x20\x0d\x0a”表示接收，以及后缀为“###@@@”的数据，完成握手。<img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230249327.png"></p><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230253151.png"><br>另外发现，若被控端除发送正确校验数据外，还发送了其他数据，主控端则会响应“tentarnovamente|”，是葡萄牙语的“tentar novamente”，意为重试。 </p><h1 id="5-QuasarRAT"><a href="#5-QuasarRAT" class="headerlink" title="5 QuasarRAT"></a>5 QuasarRAT</h1><h2 id="5-1-基本情况"><a href="#5-1-基本情况" class="headerlink" title="5.1 基本情况"></a>5.1 基本情况</h2><p><a href="https://github.com/quasar/Quasar">QuasarRAT</a> 由 github 用户 MaxXor 采用 C#开发，首次公开于 2014年 7月，曾名“xRAT”，主要针对 Windows 操作系统，采用计划任务和注册表项维持自身持久存在。<br>2018年2月，研究人员观察到一起通过恶意RTF文件分发QuasarRAT 作为最终有效载荷的攻击活动；2019年5月，enSilo观察到APT10使用PlugX 和 QuasarRAT 对东南亚政府和私人组织发起攻击。除此之外，著名的 APT攻击组织 “摩诃草”也曾长期使用此工具。</p><h2 id="5-2-基本特征"><a href="#5-2-基本特征" class="headerlink" title="5.2 基本特征"></a>5.2 基本特征</h2><p>QuasarRAT 使用 TCP 传输，常见监听端口为 5678，与数据传输相关的流量包中，TCP标志位均包括PSH。</p><h2 id="5-3-通信特征"><a href="#5-3-通信特征" class="headerlink" title="5.3 通信特征"></a>5.3 通信特征</h2><p>被控端主动向主控端发起 TCP连接，成功完成TCP连接后，主控端依次发送两个响应：<br><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230359350.png" alt="image-20260110230359318"><br><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230402790.png" alt="image-20260110230402761"><br>“RPCMethod: preinstall”是 QuasarRAT 的命令，用于在目标主机上预安装Quasar客户端，是QuasarRAT主控端区别于其他端口服务的通信特征。</p><h1 id="6-XtemeRAT"><a href="#6-XtemeRAT" class="headerlink" title="6 XtemeRAT"></a>6 XtemeRAT</h1><h2 id="6-1-基本情况"><a href="#6-1-基本情况" class="headerlink" title="6.1 基本情况"></a>6.1 基本情况</h2><p>XtemeRAT发布于2010年，使用Delphi的Unicode版本开发，在GitHub 平台上开源，主要支持功能有文件与进程管理、键盘记录、服务管理和注册表管理。曾被北非狐（APT-C-44）组织用于针对阿拉伯语地区的攻击中。</p><h2 id="6-2-基本特征"><a href="#6-2-基本特征" class="headerlink" title="6.2 基本特征"></a>6.2 基本特征</h2><p>XtremeRAT使用 TCP传输，默认监听端口为80、81、82，默认密码为1234567890。</p><h2 id="6-3-通信特征"><a href="#6-3-通信特征" class="headerlink" title="6.3 通信特征"></a>6.3 通信特征</h2><p>被控端主动发起 TCP握手，完成 TCP三次握手建立连接后，被控端首先发送版本信息“myversion|3.2”。<br><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230408184.png" alt="image-20260110230408150"><br>主控端回复第一个响应“X\n\r”，作为响应前缀，是XtremeRAT的通信特征。<br><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230412582.png" alt="image-20260110230412547"><br>着主控端回复第二个响应，payload 中第 1-8 字节为密钥，在此例中密码为1234，第9-16字节为zlib压缩文件大小，此例中消息长度为152字节，均为小端序表示，第17-18字节为zlib指示符“\x78\x01”，在XtremeRAT通信中固定。<br><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230415710.png"></p><h2 id="6-4-尝试编译源代码（没完成，后来找到了exe）"><a href="#6-4-尝试编译源代码（没完成，后来找到了exe）" class="headerlink" title="6.4 尝试编译源代码（没完成，后来找到了exe）"></a>6.4 尝试编译源代码（没完成，后来找到了exe）</h2><ol><li>在delphi2010安装virtual tree view，将文件夹复制到$(BDS)\Components\VST</li><li>delphi7上安装KOL unicode组件，或在delphi2010上安装“MirrorKOLPackageD12.dpk”。执行正常KOL安装，然后获取Unicode版本文件并替换。<br>感天动地，把那串乱码删掉就能装了</li><li>创建项目：</li></ol><ul><li>打开delphi7并转到：文件|新建|其他</li><li>选择“向导”选项。将有一个KOL调色板。</li><li>我做了一些修改，只能用作UNICODE，也就是说，不要在项目中使用“ansi”。</li><li>打开文件“XtremeRAT.rar Components”并将数据复制到文件夹“$（BDS）\Components\”</li></ul><ol><li>在delphi 2010中安装TMS组件</li><li>delphi2010|| Options | Environment Options | Delphi Options | Library - Win32 |</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">$(BDS)\Source\Indy\indy10\System<br>$(BDS)\Source\Indy\indy10\Core<br>$(BDS)\Source\Indy\indy10\协议<br>$(BDS)\Components\TMS<br></code></pre></td></tr></table></figure><ol><li>安装AlphaControls.7.26组件，安装后将文件复制到<code>$(BDS)\Components\AlphaControls\D2010</code>文件夹，然后<br>转到delphi 2010中的工具选项|选项|环境选项| delphi选项|库-Win32|<br><code>$（BDS）\Components\AlphaControls\D2010</code></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2026/01/08/i2p/"/>
    <url>/2026/01/08/i2p/</url>
    
    <content type="html"><![CDATA[<p>title: 【学习记录】I2P概述</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>I2P（Invisible Internet Project ）是去中心化的点到点（P2P）匿名网络，使用JAVA开发。与Tor类似，都是通过若干个网络节点来加密和传输数据，但匿名度比Tor更高。<br>Tor主要致力于为用户提供匿名访问实施和操作外部的互联网服务，解决“匿名性”和“隐藏服务”，侧重应用层设计，构建了一个“覆盖网络”。<br>I2P试图将现有互联网服务转移到I2P网络，并在框架内提供服务实现，提供匿名文件共享和匿名网络托管，解决“匿名性”、“隐藏服务”和“安全性”，侧重网络层设计，构建了一个“虚拟互联网”。<br>（参考：<a href="https://www.hanspub.org/journal/paperinformation?paperID=31299&btwaf=39457632%EF%BC%89">https://www.hanspub.org/journal/paperinformation?paperID=31299&amp;btwaf=39457632）</a></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol><li><p>安装<br>需要安装高于1.5的JAVA版本<br>安装教程可以在官网找到，<a href="https://geti2p.net/en/download">https://geti2p.net/en/download</a><br>（官方注：在linux上不要用root启动i2p）</p></li><li><p>连接I2P网络<br>首次连接I2P网络需要补种，后面详细说。</p></li><li><p>设置代理<br>通过I2P访问网站需要设置本地代理，默认HTTP代理端口为4444，HTTPS为4445。</p></li></ol><p>启动成功后，访问127.0.0.1:7657就能看到I2P的控制台，包括设置和各项网络指标。<img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110225516044.png" alt="在这里插入图片描述"><br>网络指标：</p><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110225756026.png" alt="在这里插入图片描述"></p><h1 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h1><ol><li>Kad算法<br> 用途：通过种子节点扩散获取网络节点信息、将传输的原始数据拆散为加密数据包通过多条隧道交叉疏散传递。</li></ol><p>  特点：<br>  ① 拿到的只是整个I2P网络的一小部分节点<br>  ② 不需要目录服务器<br>  ③ 每一台运行I2P的主机都是网络中继，共享带宽帮别人转发数据<br>  ④ 只要连上一次I2P，就能不断获取网络中部分其他节点的信息，保证与I2P网络维持连接</p><ol start="2"><li><p>网络数据库netdb<br><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110225831442.png" alt="在这里插入图片描述"></p></li><li><p>大蒜路由<br>要传输信息时，首先将要传输的信息分成多个子信息，然后从网络数据库（netdb）中随机选取可用的中间节点，构建多个加密隧道。</p><p>① 隧道<br>建立隧道时，隧道的发起者必须向发起者选出来的隧道的每一跳发送请求和必要的配置数据，并且等到每一跳的确认信息后才能开始建立隧道。隧道的发起者发送的建立隧道请求是加密的，并且只有隧道的创建者才能够访问每一跳的确认信息。隧道最大生命周期为10分钟。通常情况下，一条隧道有3跳，即网关节点、中间节点（可调整数量）、终点。一个完整的单向传输包括输出隧道和输入隧道，至少有6个节点参与其中。</p><p>② 对等实体（peer）选择<br>在选取可用中间节点中， I2P客户端依赖于先前监控的性能值和网络的当前状态，不使用有效带宽探测。I2P节点选择算法，能够非常快速地对失败的对等体和网络拓扑中的其他变化做出反应，通过不断分析和排名性能来选择对等体，而不是信任所声称的容量。<br>（参考：<a href="http://www.3n1ac.com/index.php/archives/3/%EF%BC%89">http://www.3n1ac.com/index.php/archives/3/）</a></p><p>③ 隧道创建<br>当一个路由节点想要创建一条输出隧道的时候，它会首先查看自己的netDb文件夹，获取一系列的RouterInfor信息（这个信息是之前路由实时监测得到的），根据他们的性能和其他指标从其中挑选几个节点，并且将节点根据一定的算法进行严格的排序，之后为挑选出来的每一个节点配置好相应的信息，然后转发出去。</p><p> 对于输出隧道来讲，隧道创建者就是隧道网关，将创建隧道的指令等之前配置好的信息按照之前挑选出来的、排好的顺序转发下一跳路由——隧道的中间节点，中间节点接收到指令之后，会了解到现在要创建一条隧道，它将指令会继续转发下去，然后会将请求记录替换成回复记录（说明是否同意参与隧道），继续转发到下一跳当中去。当消息一直转发到隧道的最后一个节点，即终点的时候，会按照之前的指令将消息转发到相应的输入隧道中去，最终返回到对应隧道创建者那里。</p><p> 由于隧道的构建会有较大的时间成本和带宽负载，并且每条隧道有最高10分钟的生命周期，超过这个时间之后隧道就会被销毁，所以为了实现服务的高效运行，为应用提供冗余的带宽，每个I2P路由器都会维护一系列的隧道池，每个隧道池中的隧道用于同一种通信目的。</p><p>④ 终点处理<br> 在隧道的最后一跳接收并验证了隧道消息之后，终点如何恢复网关的数据同样取决于隧道是输入隧道还是输出隧道。<br> 对于输出隧道，终点像其他参与者一样，使用其层密钥对消息进行加密、转发即可。<br> 对于输入隧道，终点也是隧道创建者，因此它们可以使用与隧道节点路由的顺序相反的顺序，使用每层加密密钥和IV（隧道初始化向量）密钥迭代地解密IV密钥和消息。</p></li></ol><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110225922691.png" alt="在这里插入图片描述"></p><h1 id="I2P与TOR对比"><a href="#I2P与TOR对比" class="headerlink" title="I2P与TOR对比"></a>I2P与TOR对比</h1><ol><li>I2P 大蒜路由<br> ① 完全去中心化，节点信息被保存在每一个I2P节点中，不需要目录服务器<br> ② 多条隧道传输接收和发送的信息，且每10分钟更换一次<br> ③ 传输的信息会被切分为多个子信息，通过不同加密隧道传输到目的地<br> ④ 速度慢</li><li>TOR 洋葱路由<br> ① 依赖目录服务器获取中继节点，容易被封禁<br> ② 单条隧道传输接收和发送的信息<br> ③ 比I2P快</li></ol><h1 id="补种"><a href="#补种" class="headerlink" title="补种"></a>补种</h1><p>由于Kad算法需要初始的种子来扩散获取更多节点信息，在初次连接I2P网络时需要补种，即利用一定数量的已知活跃节点来寻找其他节点。<br>一旦连上了I2P，就能一直联网，若一段时间不使用（超过三个月），由于没有了最新的活跃I2P节点信息，才需要重新补种。<br>I2P初始内置了种子节点信息，但有可能无效，需要其他方法补种。<br><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110225936782.png"></p><ul><li><p>补种网站、文件<br>I2P内置了几个补种网站，是默认补种方法。<br>也可以自行在补种网站上下载补种文件，要求时效性高。<br>自己可以创建补种文件分享给他人（节点信息来源于自身网络数据库）</p><p>  附部分补种网站：</p>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//banana.incognet.io/</span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//i2p.novg.net/</span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//i2pseed.creativecowpat.net:8443/</span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//reseed-fr.i2pd.xyz/</span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//reseed-pl.i2pd.xyz/</span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//reseed.diva.exchange/</span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//reseed.i2pgit.org/</span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//reseed.memcpy.io/ </span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//reseed.onion.im/</span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//reseed2.i2p.net/</span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//app.box.com/s/aednqugd5zf07mlg65wjeafay3b1qqbg/folder/88436877456</span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//www2.mk16.de/</span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//i2phides.me/i2pseeds.su3</span><br></code></pre></td></tr></table></figure></li><li><p>补种文件<br>从文件导入有zip和su3格式，su3是带有签名功能的压缩文件。<br>解压后记事本打开可以看到一个I2P路由信息，包括NTCP和SSU两个协议的host、端口、密钥等信息，即控制台中netdb所显示的内容。乱码部分是su3的文件头信息，详细表格见官方文档。<br>（官方文档：<a href="https://geti2p.net/spec/updates#su3%EF%BC%89">https://geti2p.net/spec/updates#su3）</a><br>（根据不完全观察，每小时新增70个左右）<br><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110225947226.png"></p></li></ul><h1 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h1><p>I2P匿名站点（eepsite）是I2P网络内的网站。I2P站点的名称以.i2p结尾，通过识别密钥（即加密后的base64密钥，不同于常见base64，用~代替&#x2F;，用-代替+）寻找这些站点，已知站点密钥保存在本地host.txt文件中。</p><ul><li>地址簿<br>I2P的网站密钥可以通过订阅地址簿、导航网站、自行导入地址访问。<br>如：<br><a href="http://tino.i2p/hosts.txt">http://tino.i2p/hosts.txt</a><br><a href="http://stats.i2p/cgi-bin/newhosts.txt">http://stats.i2p/cgi-bin/newhosts.txt</a><br><a href="http://i2host.i2p/cgi-bin/i2hostetag">http://i2host.i2p/cgi-bin/i2hostetag</a><br><a href="http://no.i2p/export/alive-hosts.txt">http://no.i2p/export/alive-hosts.txt</a><br><a href="http://notbob.i2p/hosts.txt">http://notbob.i2p/hosts.txt</a><br>以notbob为例，网站分类有搜索引擎、加密货币与交易、git、视频、sqbl等。<br><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230004253.png" alt="image-20260110230004197"></li><li>网站<br>首次访问未在地址簿中的网站时，可以通过跳转服务来找到该网站的密钥。<br><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230018510.png"></li></ul><h1 id="I2P与TOR术语对比"><a href="#I2P与TOR术语对比" class="headerlink" title="I2P与TOR术语对比"></a>I2P与TOR术语对比</h1><p><img src="https://raw.githubusercontent.com/q1uki/blog-images/main/img/20260110230022761.png" alt="image-20260110230022731"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2026/01/08/hello-world/"/>
    <url>/2026/01/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
